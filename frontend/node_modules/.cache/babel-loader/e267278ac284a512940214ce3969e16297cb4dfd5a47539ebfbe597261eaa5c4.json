{"ast":null,"code":"/* eslint-disable */\nimport { Utils } from './index';\nvar DecompressorHuffmanTree = /** @class */function () {\n  function DecompressorHuffmanTree(lengths) {\n    this.buildTree(lengths);\n  }\n  DecompressorHuffmanTree.init = function () {\n    var lengths;\n    var index;\n    // Generate huffman tree for lengths.\n    lengths = new Uint8Array(288);\n    index = 0;\n    while (index < 144) {\n      lengths[index++] = 8;\n    }\n    while (index < 256) {\n      lengths[index++] = 9;\n    }\n    while (index < 280) {\n      lengths[index++] = 7;\n    }\n    while (index < 288) {\n      lengths[index++] = 8;\n    }\n    DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths);\n    // Generate huffman tree for distances.\n    lengths = new Uint8Array(32);\n    index = 0;\n    while (index < 32) {\n      lengths[index++] = 5;\n    }\n    DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n  };\n  /// <summary>\n  /// Prepares data for generating huffman tree.\n  /// </summary>\n  /// <param name=\"blCount\">Array of counts of each code length.</param>\n  /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  /// <param name=\"treeSize\">Calculated tree size.</param>\n  /// <returns>Code.</returns>\n  DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n    var code = 0;\n    var treeSize = 512;\n    // Count number of codes for each code length.\n    for (var i = 0; i < lengths.length; i++) {\n      var length_1 = lengths[i];\n      if (length_1 > 0) {\n        blCount[length_1]++;\n      }\n    }\n    for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n      nextCode[bits] = code;\n      code += blCount[bits] << 16 - bits;\n      if (bits >= 10) {\n        var start = nextCode[bits] & 0x1ff80;\n        var end = code & 0x1ff80;\n        treeSize += end - start >> 16 - bits;\n      }\n    }\n    /*      if( code != 65536 )\n      throw new ZipException( \"Code lengths don't add up properly.\" );*/\n    return {\n      'code': code,\n      'treeSize': treeSize\n    };\n  };\n  /// <summary>\n  /// Generates huffman tree.\n  /// </summary>\n  /// <param name=\"blCount\">Array of counts of each code length.</param>\n  /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n  /// <param name=\"code\">Precalculated code.</param>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  /// <param name=\"treeSize\">Calculated size of the tree.</param>\n  /// <returns>Generated tree.</returns>\n  DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n    var tree = new Int16Array(treeSize);\n    var pointer = 512;\n    var increment = 1 << 7;\n    for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n      var end = code & 0x1ff80;\n      code -= blCount[bits] << 16 - bits;\n      var start = code & 0x1ff80;\n      for (var i = start; i < end; i += increment) {\n        tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16(-pointer << 4 | bits);\n        pointer += 1 << bits - 9;\n      }\n    }\n    for (var i = 0; i < lengths.length; i++) {\n      var bits = lengths[i];\n      if (bits == 0) {\n        continue;\n      }\n      code = nextCode[bits];\n      var revcode = Utils.bitReverse(code);\n      if (bits <= 9) {\n        do {\n          tree[revcode] = Utils.bitConverterInt32ToInt16(i << 4 | bits);\n          revcode += 1 << bits;\n        } while (revcode < 512);\n      } else {\n        var subTree = tree[revcode & 511];\n        var treeLen = 1 << (subTree & 15);\n        subTree = -(subTree >> 4);\n        do {\n          tree[subTree | revcode >> 9] = Utils.bitConverterInt32ToInt16(i << 4 | bits);\n          revcode += 1 << bits;\n        } while (revcode < treeLen);\n      }\n      nextCode[bits] = code + (1 << 16 - bits);\n    }\n    return tree;\n  };\n  /// <summary>\n  /// Builds huffman tree from array of code lengths.\n  /// </summary>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n    // Count of codes for each code length.\n    var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    // Numerical value of the smallest code for each code length.\n    var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var prepareData = this.prepareData(blCount, nextCode, lengths);\n    this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n  };\n  /// <summary>\n  /// Reads and decompresses one symbol.\n  /// </summary>\n  /// <param name=\"input\"></param>\n  /// <returns></returns>\n  DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n    var lookahead;\n    var symbol;\n    if ((lookahead = input.peekBits(9)) >= 0) {\n      if ((symbol = this.m_Tree[lookahead]) >= 0) {\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      }\n      var subtree = -(symbol >> 4);\n      var bitlen = symbol & 15;\n      if ((lookahead = input.peekBits(bitlen)) >= 0) {\n        symbol = this.m_Tree[subtree | lookahead >> 9];\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      } else {\n        var bits = input.availableBits;\n        lookahead = input.peekBits(bits);\n        symbol = this.m_Tree[subtree | lookahead >> 9];\n        if ((symbol & 15) <= bits) {\n          input.skipBits(symbol & 15);\n          return symbol >> 4;\n        } else {\n          return -1;\n        }\n      }\n    } else {\n      var bits = input.availableBits;\n      lookahead = input.peekBits(bits);\n      symbol = this.m_Tree[lookahead];\n      if (symbol >= 0 && (symbol & 15) <= bits) {\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      } else {\n        return -1;\n      }\n    }\n  };\n  Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n    /// <summary>\n    /// GET huffman tree for encoding and decoding lengths.\n    /// </summary>\n    get: function () {\n      return this.m_LengthTree;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n    /// <summary>\n    /// GET huffman tree for encoding and decoding distances.\n    /// </summary>\n    get: function () {\n      return this.m_DistanceTree;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /// <summary>\n  /// Maximum count of bits.\n  /// </summary>\n  DecompressorHuffmanTree.MAX_BITLEN = 15;\n  return DecompressorHuffmanTree;\n}();\nexport { DecompressorHuffmanTree };\n/* eslint-enable */","map":{"version":3,"names":["Utils","DecompressorHuffmanTree","lengths","buildTree","init","index","Uint8Array","m_LengthTree","m_DistanceTree","prototype","prepareData","blCount","nextCode","code","treeSize","i","length","length_1","bits","MAX_BITLEN","start","end","treeFromData","tree","Int16Array","pointer","increment","bitReverse","bitConverterInt32ToInt16","revcode","subTree","treeLen","m_Tree","unpackSymbol","input","lookahead","symbol","peekBits","skipBits","subtree","bitlen","availableBits","Object","defineProperty","get","enumerable","configurable"],"sources":["D:/weektable/frontend/node_modules/@syncfusion/ej2-compression/src/decompressor-huffman-tree.js"],"sourcesContent":["/* eslint-disable */\nimport { Utils } from './index';\nvar DecompressorHuffmanTree = /** @class */ (function () {\n    function DecompressorHuffmanTree(lengths) {\n        this.buildTree(lengths);\n    }\n    DecompressorHuffmanTree.init = function () {\n        var lengths;\n        var index;\n        // Generate huffman tree for lengths.\n        lengths = new Uint8Array(288);\n        index = 0;\n        while (index < 144) {\n            lengths[index++] = 8;\n        }\n        while (index < 256) {\n            lengths[index++] = 9;\n        }\n        while (index < 280) {\n            lengths[index++] = 7;\n        }\n        while (index < 288) {\n            lengths[index++] = 8;\n        }\n        DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths);\n        // Generate huffman tree for distances.\n        lengths = new Uint8Array(32);\n        index = 0;\n        while (index < 32) {\n            lengths[index++] = 5;\n        }\n        DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n    };\n    /// <summary>\n    /// Prepares data for generating huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated tree size.</param>\n    /// <returns>Code.</returns>\n    DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n        var code = 0;\n        var treeSize = 512;\n        // Count number of codes for each code length.\n        for (var i = 0; i < lengths.length; i++) {\n            var length_1 = lengths[i];\n            if (length_1 > 0) {\n                blCount[length_1]++;\n            }\n        }\n        for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n            nextCode[bits] = code;\n            code += blCount[bits] << (16 - bits);\n            if (bits >= 10) {\n                var start = nextCode[bits] & 0x1ff80;\n                var end = code & 0x1ff80;\n                treeSize += (end - start) >> (16 - bits);\n            }\n        }\n        /*      if( code != 65536 )\n          throw new ZipException( \"Code lengths don't add up properly.\" );*/\n        return { 'code': code, 'treeSize': treeSize };\n    };\n    /// <summary>\n    /// Generates huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"code\">Precalculated code.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated size of the tree.</param>\n    /// <returns>Generated tree.</returns>\n    DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n        var tree = new Int16Array(treeSize);\n        var pointer = 512;\n        var increment = 1 << 7;\n        for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n            var end = code & 0x1ff80;\n            code -= blCount[bits] << (16 - bits);\n            var start = code & 0x1ff80;\n            for (var i = start; i < end; i += increment) {\n                tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16((-pointer << 4) | bits);\n                pointer += 1 << (bits - 9);\n            }\n        }\n        for (var i = 0; i < lengths.length; i++) {\n            var bits = lengths[i];\n            if (bits == 0) {\n                continue;\n            }\n            code = nextCode[bits];\n            var revcode = Utils.bitReverse(code);\n            if (bits <= 9) {\n                do {\n                    tree[revcode] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < 512);\n            }\n            else {\n                var subTree = tree[revcode & 511];\n                var treeLen = 1 << (subTree & 15);\n                subTree = -(subTree >> 4);\n                do {\n                    tree[subTree | (revcode >> 9)] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < treeLen);\n            }\n            nextCode[bits] = code + (1 << (16 - bits));\n        }\n        return tree;\n    };\n    /// <summary>\n    /// Builds huffman tree from array of code lengths.\n    /// </summary>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n        // Count of codes for each code length.\n        var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        // Numerical value of the smallest code for each code length.\n        var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        var prepareData = this.prepareData(blCount, nextCode, lengths);\n        this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n    };\n    /// <summary>\n    /// Reads and decompresses one symbol.\n    /// </summary>\n    /// <param name=\"input\"></param>\n    /// <returns></returns>\n    DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n        var lookahead;\n        var symbol;\n        if ((lookahead = input.peekBits(9)) >= 0) {\n            if ((symbol = this.m_Tree[lookahead]) >= 0) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            var subtree = -(symbol >> 4);\n            var bitlen = symbol & 15;\n            if ((lookahead = input.peekBits(bitlen)) >= 0) {\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                var bits = input.availableBits;\n                lookahead = input.peekBits(bits);\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                if ((symbol & 15) <= bits) {\n                    input.skipBits((symbol & 15));\n                    return symbol >> 4;\n                }\n                else {\n                    return -1;\n                }\n            }\n        }\n        else {\n            var bits = input.availableBits;\n            lookahead = input.peekBits(bits);\n            symbol = this.m_Tree[lookahead];\n            if (symbol >= 0 && (symbol & 15) <= bits) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                return -1;\n            }\n        }\n    };\n    Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding lengths.\n        /// </summary>\n        get: function () {\n            return this.m_LengthTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding distances.\n        /// </summary>\n        get: function () {\n            return this.m_DistanceTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Maximum count of bits.\n    /// </summary>\n    DecompressorHuffmanTree.MAX_BITLEN = 15;\n    return DecompressorHuffmanTree;\n}());\nexport { DecompressorHuffmanTree };\n/* eslint-enable */ \n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}