{"ast":null,"code":"/* eslint-disable */\nimport { CompressedStreamWriter, Stream, CompressedStreamReader } from './index';\nimport { Save } from '@syncfusion/ej2-file-utils';\nimport { Utils } from './utils';\nvar CRC32TABLE = [];\n/// <summary>\n/// Size of the int value in bytes.\n/// </summary>\nvar INT_SIZE = 4;\n/// <summary>\n/// Size of the short value in bytes.\n/// </summary>\nvar SHORT_SIZE = 2;\n/// <summary>\n/// End of central directory signature.\n/// </summary>\nvar CentralDirectoryEndSignature = 0x06054b50;\n/// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\nvar CentralDirSizeOffset = 12;\n/// <summary>\n/// Central header signature.\n/// </summary>\nvar CentralHeaderSignature = 0x02014b50;\n/// <summary>\n/// Buffer size.\n/// </summary>\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */function () {\n  /**\n   * constructor for creating ZipArchive instance\n   */\n  function ZipArchive() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  Object.defineProperty(ZipArchive.prototype, \"items\", {\n    get: function () {\n      return this.files;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n    /**\n     * gets compression level\n     */\n    get: function () {\n      return this.level;\n    },\n    /**\n     * sets compression level\n     */\n    set: function (level) {\n      this.level = level;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"length\", {\n    /**\n     * gets items count\n     */\n    get: function () {\n      if (this.files === undefined) {\n        return 0;\n      }\n      return this.files.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n  ZipArchive.prototype.addItem = function (item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n    for (var i = 0; i < this.files.length; i++) {\n      var file = this.files[i];\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n    this.files.push(item);\n  };\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n  ZipArchive.prototype.addDirectory = function (directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n    this.files.push(directoryName);\n  };\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n  ZipArchive.prototype.getItem = function (index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n    return undefined;\n  };\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n  ZipArchive.prototype.contains = function (item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  };\n  ZipArchive.prototype.open = function (base64String) {\n    //return promise = new Promise((resolve: Function, reject: Function) => {\n    var zipArchive = this;\n    var zipByteArray = Utils.encodedString(base64String);\n    if (zipByteArray.length == 0) throw new DOMException(\"stream\");\n    var stream = new Stream(zipByteArray);\n    //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n    var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n    if (lCentralDirEndPosition < 0) throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\");\n    // Step2. Locate central directory and iterate through all items\n    stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n    var iCentralDirSize = ZipArchive.ReadInt32(stream);\n    var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;\n    // verify that this is really central directory\n    stream.position = lCentralDirPosition;\n    this.readCentralDirectoryDataAndExtractItems(stream);\n    //});\n    // let zipArchive: ZipArchive = this;\n    //let promise: Promise<ZipArchive>;\n    // return promise = new Promise((resolve: Function, reject: Function) => {\n    //     let reader: FileReader = new FileReader();\n    //     reader.onload = (e: Event) => {\n    //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n    //         let zipReader: ZipReader = new ZipReader(data);\n    //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n    //             for (let i: number = 0; i < entries.length; i++) {\n    //                 let entry: ZipEntry = entries[i];\n    //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n    //                 item.data = entry.data;\n    //                 item.compressionMethod = entry.compressionMethod;\n    //                 item.crc = entry.crc;\n    //                 item.lastModified = entry.lastModified;\n    //                 item.lastModifiedDate = entry.lastModifiedDate;\n    //                 item.size = entry.size;\n    //                 item.uncompressedSize = entry.uncompressedSize;\n    //                 zipArchive.addItem(item);\n    //             }\n    //             resolve(zipArchive);\n    //         });\n    //     };\n    //     reader.readAsArrayBuffer(fileName);\n    // });\n  };\n  /// <summary>\n  /// Read central directory record from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read from.</param>\n  ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n    if (stream == null) throw new DOMException(\"stream\");\n    var itemHelper;\n    while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n      itemHelper = new ZipArchiveItemHelper();\n      itemHelper.readCentralDirectoryData(stream);\n      itemHelper;\n      // let item: ZipArchiveItem = new ZipArchiveItem(this);\n      // item.ReadCentralDirectoryData(stream);\n      // m_arrItems.Add(item);\n    }\n    itemHelper.readData(stream, itemHelper.checkCrc);\n    itemHelper.decompressData();\n    this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n  };\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n  ZipArchive.prototype.save = function (fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal(fileName, false).then(function () {\n        resolve(zipArchive);\n      });\n    });\n  };\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n  ZipArchive.prototype.saveAsBlob = function () {\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal('', true).then(function (blob) {\n        resolve(blob);\n      });\n    });\n  };\n  ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n    var _this = this;\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      var zipData = [];\n      var dirLength = 0;\n      for (var i = 0; i < zipArchive.files.length; i++) {\n        var compressedObject = _this.getCompressedData(_this.files[i]);\n        compressedObject.then(function (data) {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n          if (zipData.length === zipArchive.files.length) {\n            var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n  ZipArchive.prototype.destroy = function () {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (var i = 0; i < this.files.length; i++) {\n        var file = this.files[i];\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n        file = undefined;\n      }\n      this.files = [];\n    }\n    this.files = undefined;\n    this.level = undefined;\n  };\n  ZipArchive.prototype.getCompressedData = function (item) {\n    var zipArchive = this;\n    var promise = new Promise(function (resolve, reject) {\n      if (item instanceof ZipArchiveItem) {\n        var reader_1 = new FileReader();\n        reader_1.onload = function () {\n          var input = new Uint8Array(reader_1.result);\n          var data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            var length_1 = 0;\n            for (var i = 0; i < data.compressedData.length; i++) {\n              length_1 += data.compressedData[i].length;\n            }\n            data.compressedSize = length_1;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n            data.compressedData.push(input);\n          }\n          resolve(data);\n        };\n        reader_1.readAsArrayBuffer(item.data);\n      } else {\n        var data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  };\n  ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n    var compressor = new CompressedStreamWriter(true);\n    var currentIndex = 0;\n    var nextIndex = 0;\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      var subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  };\n  ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n    var extFileAttr = 0;\n    var date = new Date();\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    var header = this.writeHeader(data, date);\n    var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  };\n  ZipArchive.prototype.writeHeader = function (data, date) {\n    var zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n    zipHeader += this.getBytes(0, 2); // extra field length\n    return zipHeader;\n  };\n  ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n    var cenDirLen = 0;\n    var buffer = [];\n    for (var i = 0; i < zipData.length; i++) {\n      var item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n    for (var i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    var blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n    return blob;\n  };\n  ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n    var directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader +\n    // inherit from file header\n    this.getBytes(0, 2) +\n    // comment length\n    '\\x00\\x00' + '\\x00\\x00' +\n    // internal file attributes \n    this.getBytes(externalFileAttribute, 4) +\n    // external file attributes\n    this.getBytes(offset, 4) +\n    // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  };\n  ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n    var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  };\n  ZipArchive.prototype.getArrayBuffer = function (input) {\n    var a = new Uint8Array(input.length);\n    for (var j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n    return a.buffer;\n  };\n  ZipArchive.prototype.getBytes = function (value, offset) {\n    var bytes = '';\n    for (var i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n    return bytes;\n  };\n  ZipArchive.prototype.getModifiedTime = function (date) {\n    var modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  };\n  ZipArchive.prototype.getModifiedDate = function (date) {\n    var modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  };\n  ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n    for (var i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n    return crc32Value ^ -1;\n  };\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n  ZipArchive.initCrc32Table = function () {\n    var i;\n    for (var j = 0; j < 256; j++) {\n      i = j;\n      for (var k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n      CRC32TABLE[j] = i;\n    }\n  };\n  ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n    if (stream == null) throw new DOMException(\"stream\");\n    //   if( !stream.CanSeek || !stream.CanRead )\n    //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n    // read last 4 bytes and compare with required value\n    var lStreamSize = stream.inputStream.buffer.byteLength;\n    if (lStreamSize < 4) return -1;\n    var arrBuffer = new Uint8Array(4);\n    var lLastPos = Math.max(0, lStreamSize - maxCount);\n    var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n    stream.position = lCurrentPosition;\n    stream.read(arrBuffer, 0, INT_SIZE);\n    var uiCurValue = arrBuffer[0];\n    var bFound = uiCurValue == value;\n    if (!bFound) {\n      while (lCurrentPosition > lLastPos) {\n        // remove unnecessary byte and replace it with new value.\n        uiCurValue <<= 8;\n        lCurrentPosition--;\n        stream.position = lCurrentPosition;\n        uiCurValue += stream.readByte();\n        if (uiCurValue == value) {\n          bFound = true;\n          break;\n        }\n      }\n    }\n    return bFound ? lCurrentPosition : -1;\n  };\n  /// <summary>\n  /// Extracts Int32 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n  ZipArchive.ReadInt32 = function (stream) {\n    var buffer = new Uint8Array(INT_SIZE);\n    if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n      throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n    }\n    return Utils.bitConverterToInt32(buffer, 0);\n  };\n  /// <summary>\n  /// Extracts Int16 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n  ZipArchive.ReadInt16 = function (stream) {\n    var buffer = new Uint8Array(SHORT_SIZE);\n    if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n      throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n    }\n    return Utils.bitConverterToInt16(buffer, 0);\n  };\n  /// <summary>\n  /// Extracts unsigned Int16 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n  ZipArchive.ReadUInt16 = function (stream) {\n    {\n      var buffer = new Uint8Array(SHORT_SIZE);\n      if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n        throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n      }\n      return Utils.bitConverterToInt16(buffer, 0);\n    }\n  };\n  return ZipArchive;\n}();\nexport { ZipArchive };\nvar ZipArchiveItemHelper = /** @class */function () {\n  function ZipArchiveItemHelper() {\n    /// <summary>\n    /// Zip header signature.\n    /// </summary>\n    this.headerSignature = 0x04034b50;\n    /// <summary>\n    /// Indicates whether we should check Crc value when reading item's data. Check\n    /// is performed when user gets access to decompressed data for the first time.\n    /// </summary>\n    this.checkCrc = true;\n    /// <summary>\n    /// Crc.\n    /// </summary>\n    this.crc32 = 0;\n  }\n  /// <summary>\n  /// Read data from the stream based on the central directory.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n  ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n    // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n    stream.position += 4;\n    this.options = ZipArchive.ReadInt16(stream);\n    this.compressionMethod = ZipArchive.ReadInt16(stream);\n    this.checkCrc = this.compressionMethod != 99; //COmpression.Defalte != SecurityConstants.AES\n    //m_bCompressed = true;\n    // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n    var lastModified = ZipArchive.ReadInt32(stream);\n    //LastModified = ConvertToDateTime(lastModified);\n    this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n    this.compressedSize = ZipArchive.ReadInt32(stream);\n    this.originalSize = ZipArchive.ReadInt32(stream);\n    var iFileNameLength = ZipArchive.ReadInt16(stream);\n    var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n    var iCommentLength = ZipArchive.ReadInt16(stream);\n    // on the current moment we ignore and \"disk number start\" (2 bytes),\n    // \"internal file attributes\" (2 bytes).\n    stream.position += 4;\n    this.externalAttributes = ZipArchive.ReadInt32(stream);\n    this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n    var arrBuffer = new Uint8Array(iFileNameLength);\n    stream.read(arrBuffer, 0, iFileNameLength);\n    var m_strItemName = Utils.byteToString(arrBuffer);\n    m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n    this.name = m_strItemName;\n    stream.position += iExtraFieldLenth + iCommentLength;\n    if (this.options != 0) this.options = 0;\n  };\n  /// <summary>\n  /// Reads zipped data from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n  ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n    if (stream.length == 0) throw new DOMException(\"stream\");\n    stream.position = this.localHeaderOffset;\n    this.checkCrc = checkCrc;\n    this.readLocalHeader(stream);\n    this.readCompressedData(stream);\n  };\n  ZipArchiveItemHelper.prototype.decompressData = function () {\n    if (this.compressionMethod == 8) {\n      if (this.originalSize > 0) {\n        this.decompressDataOld();\n      }\n    }\n  };\n  ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n    var reader = new CompressedStreamReader(this.compressedStream, true);\n    var decompressedData;\n    if (this.originalSize > 0) decompressedData = new Stream(new Uint8Array(this.originalSize));\n    var arrBuffer = new Uint8Array(BufferSize);\n    var iReadBytes;\n    var past = new Uint8Array(0);\n    while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n      //             past = new Uint8Array(decompressedData.length);\n      // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n      decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n    }\n    this.unCompressedStream = decompressedData.toByteArray();\n    //   this.originalSize = decompressedData.Length;\n    //   m_bControlStream = true;\n    //   m_streamData = decompressedData;\n    //   decompressedData.SetLength( m_lOriginalSize );\n    //   decompressedData.Capacity = ( int )m_lOriginalSize;\n    if (this.checkCrc) {\n      //TODO: fix this\n      //CheckCrc(decompressedData.ToArray());\n    }\n    //m_streamData.Position = 0;\n  };\n  /// <summary>\n  /// Extracts local header from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n    if (stream.length == 0) throw new DOMException(\"stream\");\n    if (ZipArchive.ReadInt32(stream) != this.headerSignature) throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\");\n    // TODO: it is good to verify data read from the central directory record,\n    // but on the current moment we simply skip it.\n    stream.position += 22;\n    var iNameLength = ZipArchive.ReadInt16(stream);\n    var iExtraLength = ZipArchive.ReadUInt16(stream);\n    if (this.compressionMethod == 99)\n      //SecurityConstants.AES\n      {\n        // stream.Position += iNameLength + 8;\n        // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n        // m_actualCompression = new byte[2];\n        // stream.Read(m_actualCompression, 0, 2);\n      } else if (iExtraLength > 2) {\n      stream.position += iNameLength;\n      var headerVal = ZipArchive.ReadInt16(stream);\n      if (headerVal == 0x0017)\n        //PKZipEncryptionHeader\n        throw new DOMException(\"UnSupported\");else stream.position += iExtraLength - 2;\n    } else stream.position += iNameLength + iExtraLength;\n  };\n  /// <summary>\n  /// Extracts compressed data from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n    var dataStream;\n    if (this.compressedSize > 0) {\n      var iBytesLeft = this.compressedSize;\n      dataStream = new Stream(new Uint8Array(iBytesLeft));\n      var arrBuffer = new Uint8Array(BufferSize);\n      while (iBytesLeft > 0) {\n        var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n        if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead) throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n        dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n        iBytesLeft -= iBytesToRead;\n      }\n      // if(m_archive.Password != null)\n      // {\n      //     byte[] dataBuffer = new byte[dataStream.Length];\n      //     dataBuffer = dataStream.ToArray();\n      //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n      // }\n      this.compressedStream = new Uint8Array(dataStream.inputStream);\n      // m_bControlStream = true;\n    } else if (this.compressedSize < 0)\n      //If compression size is negative, then read until the next header signature reached.\n      {\n        //   MemoryStream dataStream = new MemoryStream();\n        //   int bt = 0;\n        //   bool proceed=true;\n        //   while (proceed)\n        //   {\n        //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n        //       {\n        //           stream.Position -= 1;\n        //           int headerSignature = ZipArchive.ReadInt32(stream);\n        //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n        //           {\n        //               proceed = false;\n        //           }\n        //           stream.Position -= 3;\n        //       }\n        //       if (proceed)\n        //           dataStream.WriteByte((byte)bt);\n        //   }\n        //   m_streamData = dataStream;\n        //   m_lCompressedSize = m_streamData.Length;\n        //   m_bControlStream = true;\n      } else if (this.compressedSize == 0) {\n      //  m_streamData = new MemoryStream();\n    }\n  };\n  return ZipArchiveItemHelper;\n}();\nexport { ZipArchiveItemHelper };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */function () {\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n  function ZipArchiveItem(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n    this.data = data;\n    this.name = itemName;\n  }\n  Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n    get: function () {\n      return this.decompressedStream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get: function () {\n      return this.fileName;\n    },\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set: function (value) {\n      this.fileName = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n  ZipArchiveItem.prototype.destroy = function () {\n    this.fileName = undefined;\n    this.data = undefined;\n  };\n  return ZipArchiveItem;\n}();\nexport { ZipArchiveItem };\n/* eslint-enable */","map":{"version":3,"names":["CompressedStreamWriter","Stream","CompressedStreamReader","Save","Utils","CRC32TABLE","INT_SIZE","SHORT_SIZE","CentralDirectoryEndSignature","CentralDirSizeOffset","CentralHeaderSignature","BufferSize","ZipArchive","length","initCrc32Table","files","level","isMicrosoftBrowser","navigator","msSaveBlob","Object","defineProperty","prototype","get","enumerable","configurable","set","undefined","addItem","item","Error","i","file","ZipArchiveItem","name","push","addDirectory","directoryName","slice","indexOf","getItem","index","contains","open","base64String","zipArchive","zipByteArray","encodedString","DOMException","stream","lCentralDirEndPosition","findValueFromEnd","position","iCentralDirSize","ReadInt32","lCentralDirPosition","readCentralDirectoryDataAndExtractItems","itemHelper","ZipArchiveItemHelper","readCentralDirectoryData","readData","checkCrc","decompressData","unCompressedStream","buffer","save","fileName","promise","Promise","resolve","reject","saveInternal","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","compressedObject","getCompressedData","data","constructZippedObject","isDirectory","writeZippedContent","destroy","reader_1","FileReader","onload","input","Uint8Array","result","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","compressData","length_1","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","currentIndex","nextIndex","close","Math","min","subArray","subarray","write","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getBytes","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","Blob","type","offset","externalFileAttribute","directoryHeader","centralLength","localLength","dirEnd","a","j","charCodeAt","value","bytes","String","fromCharCode","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","k","maxCount","lStreamSize","inputStream","byteLength","arrBuffer","lLastPos","max","lCurrentPosition","read","uiCurValue","bFound","readByte","bitConverterToInt32","ReadInt16","bitConverterToInt16","ReadUInt16","headerSignature","crc32","options","compressionMethod","lastModified","bitConverterToUInt32","originalSize","iFileNameLength","iExtraFieldLenth","iCommentLength","externalAttributes","localHeaderOffset","m_strItemName","byteToString","replace","readLocalHeader","readCompressedData","decompressDataOld","reader","compressedStream","decompressedData","iReadBytes","past","toByteArray","iNameLength","iExtraLength","headerVal","dataStream","iBytesLeft","iBytesToRead","itemName","decompressedStream"],"sources":["D:/weektable/frontend/node_modules/@syncfusion/ej2-compression/src/zip-archive.js"],"sourcesContent":["/* eslint-disable */\nimport { CompressedStreamWriter, Stream, CompressedStreamReader } from './index';\nimport { Save } from '@syncfusion/ej2-file-utils';\nimport { Utils } from './utils';\nvar CRC32TABLE = [];\n/// <summary>\n/// Size of the int value in bytes.\n/// </summary>\nvar INT_SIZE = 4;\n/// <summary>\n/// Size of the short value in bytes.\n/// </summary>\nvar SHORT_SIZE = 2;\n/// <summary>\n/// End of central directory signature.\n/// </summary>\nvar CentralDirectoryEndSignature = 0x06054b50;\n/// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\nvar CentralDirSizeOffset = 12;\n/// <summary>\n/// Central header signature.\n/// </summary>\nvar CentralHeaderSignature = 0x02014b50;\n/// <summary>\n/// Buffer size.\n/// </summary>\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"items\", {\n        get: function () {\n            return this.files;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    ZipArchive.prototype.open = function (base64String) {\n        //return promise = new Promise((resolve: Function, reject: Function) => {\n        var zipArchive = this;\n        var zipByteArray = Utils.encodedString(base64String);\n        if (zipByteArray.length == 0)\n            throw new DOMException(\"stream\");\n        var stream = new Stream(zipByteArray);\n        //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n        var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n        if (lCentralDirEndPosition < 0)\n            throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\");\n        // Step2. Locate central directory and iterate through all items\n        stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n        var iCentralDirSize = ZipArchive.ReadInt32(stream);\n        var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;\n        // verify that this is really central directory\n        stream.position = lCentralDirPosition;\n        this.readCentralDirectoryDataAndExtractItems(stream);\n        //});\n        // let zipArchive: ZipArchive = this;\n        //let promise: Promise<ZipArchive>;\n        // return promise = new Promise((resolve: Function, reject: Function) => {\n        //     let reader: FileReader = new FileReader();\n        //     reader.onload = (e: Event) => {\n        //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n        //         let zipReader: ZipReader = new ZipReader(data);\n        //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n        //             for (let i: number = 0; i < entries.length; i++) {\n        //                 let entry: ZipEntry = entries[i];\n        //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n        //                 item.data = entry.data;\n        //                 item.compressionMethod = entry.compressionMethod;\n        //                 item.crc = entry.crc;\n        //                 item.lastModified = entry.lastModified;\n        //                 item.lastModifiedDate = entry.lastModifiedDate;\n        //                 item.size = entry.size;\n        //                 item.uncompressedSize = entry.uncompressedSize;\n        //                 zipArchive.addItem(item);\n        //             }\n        //             resolve(zipArchive);\n        //         });\n        //     };\n        //     reader.readAsArrayBuffer(fileName);\n        // });\n    };\n    /// <summary>\n    /// Read central directory record from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read from.</param>\n    ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        var itemHelper;\n        while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n            itemHelper = new ZipArchiveItemHelper();\n            itemHelper.readCentralDirectoryData(stream);\n            itemHelper;\n            // let item: ZipArchiveItem = new ZipArchiveItem(this);\n            // item.ReadCentralDirectoryData(stream);\n            // m_arrItems.Add(item);\n        }\n        itemHelper.readData(stream, itemHelper.checkCrc);\n        itemHelper.decompressData();\n        this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    ZipArchive.initCrc32Table = function () {\n        var i;\n        for (var j = 0; j < 256; j++) {\n            i = j;\n            for (var k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    };\n    ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        //   if( !stream.CanSeek || !stream.CanRead )\n        //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n        // read last 4 bytes and compare with required value\n        var lStreamSize = stream.inputStream.buffer.byteLength;\n        if (lStreamSize < 4)\n            return -1;\n        var arrBuffer = new Uint8Array(4);\n        var lLastPos = Math.max(0, lStreamSize - maxCount);\n        var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n        stream.position = lCurrentPosition;\n        stream.read(arrBuffer, 0, INT_SIZE);\n        var uiCurValue = arrBuffer[0];\n        var bFound = (uiCurValue == value);\n        if (!bFound) {\n            while (lCurrentPosition > lLastPos) {\n                // remove unnecessary byte and replace it with new value.\n                uiCurValue <<= 8;\n                lCurrentPosition--;\n                stream.position = lCurrentPosition;\n                uiCurValue += stream.readByte();\n                if (uiCurValue == value) {\n                    bFound = true;\n                    break;\n                }\n            }\n        }\n        return bFound ? lCurrentPosition : -1;\n    };\n    /// <summary>\n    /// Extracts Int32 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt32 = function (stream) {\n        var buffer = new Uint8Array(INT_SIZE);\n        if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt32(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt16 = function (stream) {\n        var buffer = new Uint8Array(SHORT_SIZE);\n        if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt16(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts unsigned Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadUInt16 = function (stream) {\n        {\n            var buffer = new Uint8Array(SHORT_SIZE);\n            if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n                throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n            }\n            return Utils.bitConverterToInt16(buffer, 0);\n        }\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\nvar ZipArchiveItemHelper = /** @class */ (function () {\n    function ZipArchiveItemHelper() {\n        /// <summary>\n        /// Zip header signature.\n        /// </summary>\n        this.headerSignature = 0x04034b50;\n        /// <summary>\n        /// Indicates whether we should check Crc value when reading item's data. Check\n        /// is performed when user gets access to decompressed data for the first time.\n        /// </summary>\n        this.checkCrc = true;\n        /// <summary>\n        /// Crc.\n        /// </summary>\n        this.crc32 = 0;\n    }\n    /// <summary>\n    /// Read data from the stream based on the central directory.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n    ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n        // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n        stream.position += 4;\n        this.options = ZipArchive.ReadInt16(stream);\n        this.compressionMethod = ZipArchive.ReadInt16(stream);\n        this.checkCrc = (this.compressionMethod != 99); //COmpression.Defalte != SecurityConstants.AES\n        //m_bCompressed = true;\n        // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n        var lastModified = ZipArchive.ReadInt32(stream);\n        //LastModified = ConvertToDateTime(lastModified);\n        this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n        this.compressedSize = ZipArchive.ReadInt32(stream);\n        this.originalSize = ZipArchive.ReadInt32(stream);\n        var iFileNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n        var iCommentLength = ZipArchive.ReadInt16(stream);\n        // on the current moment we ignore and \"disk number start\" (2 bytes),\n        // \"internal file attributes\" (2 bytes).\n        stream.position += 4;\n        this.externalAttributes = ZipArchive.ReadInt32(stream);\n        this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n        var arrBuffer = new Uint8Array(iFileNameLength);\n        stream.read(arrBuffer, 0, iFileNameLength);\n        var m_strItemName = Utils.byteToString(arrBuffer);\n        m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n        this.name = m_strItemName;\n        stream.position += iExtraFieldLenth + iCommentLength;\n        if (this.options != 0)\n            this.options = 0;\n    };\n    /// <summary>\n    /// Reads zipped data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n    ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        stream.position = this.localHeaderOffset;\n        this.checkCrc = checkCrc;\n        this.readLocalHeader(stream);\n        this.readCompressedData(stream);\n    };\n    ZipArchiveItemHelper.prototype.decompressData = function () {\n        if (this.compressionMethod == 8) {\n            if (this.originalSize > 0) {\n                this.decompressDataOld();\n            }\n        }\n    };\n    ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n        var reader = new CompressedStreamReader(this.compressedStream, true);\n        var decompressedData;\n        if (this.originalSize > 0)\n            decompressedData = new Stream(new Uint8Array(this.originalSize));\n        var arrBuffer = new Uint8Array(BufferSize);\n        var iReadBytes;\n        var past = new Uint8Array(0);\n        while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n            //             past = new Uint8Array(decompressedData.length);\n            // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n            decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n        }\n        this.unCompressedStream = decompressedData.toByteArray();\n        //   this.originalSize = decompressedData.Length;\n        //   m_bControlStream = true;\n        //   m_streamData = decompressedData;\n        //   decompressedData.SetLength( m_lOriginalSize );\n        //   decompressedData.Capacity = ( int )m_lOriginalSize;\n        if (this.checkCrc) {\n            //TODO: fix this\n            //CheckCrc(decompressedData.ToArray());\n        }\n        //m_streamData.Position = 0;\n    };\n    /// <summary>\n    /// Extracts local header from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        if (ZipArchive.ReadInt32(stream) != this.headerSignature)\n            throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\");\n        // TODO: it is good to verify data read from the central directory record,\n        // but on the current moment we simply skip it.\n        stream.position += 22;\n        var iNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraLength = ZipArchive.ReadUInt16(stream);\n        if (this.compressionMethod == 99) //SecurityConstants.AES\n         {\n            // stream.Position += iNameLength + 8;\n            // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n            // m_actualCompression = new byte[2];\n            // stream.Read(m_actualCompression, 0, 2);\n        }\n        else if (iExtraLength > 2) {\n            stream.position += iNameLength;\n            var headerVal = ZipArchive.ReadInt16(stream);\n            if (headerVal == 0x0017) //PKZipEncryptionHeader\n                throw new DOMException(\"UnSupported\");\n            else\n                stream.position += iExtraLength - 2;\n        }\n        else\n            stream.position += iNameLength + iExtraLength;\n    };\n    /// <summary>\n    /// Extracts compressed data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n        var dataStream;\n        if (this.compressedSize > 0) {\n            var iBytesLeft = this.compressedSize;\n            dataStream = new Stream(new Uint8Array(iBytesLeft));\n            var arrBuffer = new Uint8Array(BufferSize);\n            while (iBytesLeft > 0) {\n                var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n                if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead)\n                    throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n                dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n                iBytesLeft -= iBytesToRead;\n            }\n            // if(m_archive.Password != null)\n            // {\n            //     byte[] dataBuffer = new byte[dataStream.Length];\n            //     dataBuffer = dataStream.ToArray();\n            //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n            // }\n            this.compressedStream = new Uint8Array(dataStream.inputStream);\n            // m_bControlStream = true;\n        }\n        else if (this.compressedSize < 0) //If compression size is negative, then read until the next header signature reached.\n         {\n            //   MemoryStream dataStream = new MemoryStream();\n            //   int bt = 0;\n            //   bool proceed=true;\n            //   while (proceed)\n            //   {\n            //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n            //       {\n            //           stream.Position -= 1;\n            //           int headerSignature = ZipArchive.ReadInt32(stream);\n            //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n            //           {\n            //               proceed = false;\n            //           }\n            //           stream.Position -= 3;\n            //       }\n            //       if (proceed)\n            //           dataStream.WriteByte((byte)bt);\n            //   }\n            //   m_streamData = dataStream;\n            //   m_lCompressedSize = m_streamData.Length;\n            //   m_bControlStream = true;\n        }\n        else if (this.compressedSize == 0) {\n            //  m_streamData = new MemoryStream();\n        }\n    };\n    return ZipArchiveItemHelper;\n}());\nexport { ZipArchiveItemHelper };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n        get: function () {\n            return this.decompressedStream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n/* eslint-enable */ \n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}