{"ast":null,"code":"/**\n * Collision module.\n */\nimport { calculatePosition } from './position';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nvar parentDocument;\nvar targetContainer;\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision coordinates\n * @param {OffsetPosition} position - specifies the position\n * @returns {void}\n */\nexport function fit(element, viewPortElement, axis, position) {\n  if (viewPortElement === void 0) {\n    viewPortElement = null;\n  }\n  if (axis === void 0) {\n    axis = {\n      X: false,\n      Y: false\n    };\n  }\n  if (!axis.Y && !axis.X) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n  var elemData = element.getBoundingClientRect();\n  targetContainer = viewPortElement;\n  parentDocument = element.ownerDocument;\n  if (!position) {\n    position = calculatePosition(element, 'left', 'top');\n  }\n  if (axis.X) {\n    var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();\n    var containerLeft = ContainerLeft();\n    var containerRight = ContainerRight();\n    var overLeft = containerLeft - position.left;\n    var overRight = position.left + elemData.width - containerRight;\n    if (elemData.width > containerWidth) {\n      if (overLeft > 0 && overRight <= 0) {\n        position.left = containerRight - elemData.width;\n      } else if (overRight > 0 && overLeft <= 0) {\n        position.left = containerLeft;\n      } else {\n        position.left = overLeft > overRight ? containerRight - elemData.width : containerLeft;\n      }\n    } else if (overLeft > 0) {\n      position.left += overLeft;\n    } else if (overRight > 0) {\n      position.left -= overRight;\n    }\n  }\n  if (axis.Y) {\n    var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();\n    var containerTop = ContainerTop();\n    var containerBottom = ContainerBottom();\n    var overTop = containerTop - position.top;\n    var overBottom = position.top + elemData.height - containerBottom;\n    if (elemData.height > containerHeight) {\n      if (overTop > 0 && overBottom <= 0) {\n        position.top = containerBottom - elemData.height;\n      } else if (overBottom > 0 && overTop <= 0) {\n        position.top = containerTop;\n      } else {\n        position.top = overTop > overBottom ? containerBottom - elemData.height : containerTop;\n      }\n    } else if (overTop > 0) {\n      position.top += overTop;\n    } else if (overBottom > 0) {\n      position.top -= overBottom;\n    }\n  }\n  return position;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the html element\n * @param {HTMLElement} viewPortElement - specifies the html element\n * @param {number} x - specifies the number\n * @param {number} y - specifies the number\n * @returns {string[]} - returns the string value\n */\nexport function isCollide(element, viewPortElement, x, y) {\n  if (viewPortElement === void 0) {\n    viewPortElement = null;\n  }\n  var elemOffset = calculatePosition(element, 'left', 'top');\n  if (x) {\n    elemOffset.left = x;\n  }\n  if (y) {\n    elemOffset.top = y;\n  }\n  var data = [];\n  targetContainer = viewPortElement;\n  parentDocument = element.ownerDocument;\n  var elementRect = element.getBoundingClientRect();\n  var top = elemOffset.top;\n  var left = elemOffset.left;\n  var right = elemOffset.left + elementRect.width;\n  var bottom = elemOffset.top + elementRect.height;\n  var yAxis = topCollideCheck(top, bottom);\n  var xAxis = leftCollideCheck(left, right);\n  if (yAxis.topSide) {\n    data.push('top');\n  }\n  if (xAxis.rightSide) {\n    data.push('right');\n  }\n  if (xAxis.leftSide) {\n    data.push('left');\n  }\n  if (yAxis.bottomSide) {\n    data.push('bottom');\n  }\n  return data;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} target - specifies the element\n * @param {number} offsetX - specifies the number\n * @param {number} offsetY - specifies the number\n * @param {string} positionX - specifies the string value\n * @param {string} positionY - specifies the string value\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision axis\n * @param {boolean} fixedParent - specifies the boolean\n * @returns {void}\n */\nexport function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, /* eslint-disable */\naxis, fixedParent) {\n  if (viewPortElement === void 0) {\n    viewPortElement = null;\n  }\n  if (axis === void 0) {\n    axis = {\n      X: true,\n      Y: true\n    };\n  }\n  if (!target || !element || !positionX || !positionY || !axis.X && !axis.Y) {\n    return;\n  }\n  var tEdge = {\n      TL: null,\n      TR: null,\n      BL: null,\n      BR: null\n    },\n    eEdge = {\n      TL: null,\n      TR: null,\n      BL: null,\n      BR: null\n      /* eslint-enable */\n    };\n  var elementRect;\n  if (window.getComputedStyle(element).display === 'none') {\n    var oldVisibility = element.style.visibility;\n    element.style.visibility = 'hidden';\n    element.style.display = 'block';\n    elementRect = element.getBoundingClientRect();\n    element.style.removeProperty('display');\n    element.style.visibility = oldVisibility;\n  } else {\n    elementRect = element.getBoundingClientRect();\n  }\n  var pos = {\n    posX: positionX,\n    posY: positionY,\n    offsetX: offsetX,\n    offsetY: offsetY,\n    position: {\n      left: 0,\n      top: 0\n    }\n  };\n  targetContainer = viewPortElement;\n  parentDocument = target.ownerDocument;\n  updateElementData(target, tEdge, pos, fixedParent, elementRect);\n  setPosition(eEdge, pos, elementRect);\n  if (axis.X) {\n    leftFlip(target, eEdge, tEdge, pos, elementRect, true);\n  }\n  if (axis.Y && tEdge.TL.top > -1) {\n    topFlip(target, eEdge, tEdge, pos, elementRect, true);\n  }\n  setPopup(element, pos, elementRect);\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\nfunction setPopup(element, pos, elementRect) {\n  var left = 0;\n  var top = 0;\n  if (element.offsetParent != null && (getComputedStyle(element.offsetParent).position === 'absolute' || getComputedStyle(element.offsetParent).position === 'relative')) {\n    var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);\n    left = data.left;\n    top = data.top;\n  }\n  var scaleX = 1;\n  var scaleY = 1;\n  var tranformElement = getTransformElement(element);\n  if (tranformElement) {\n    var transformStyle = getComputedStyle(tranformElement).transform;\n    if (transformStyle !== 'none') {\n      var matrix = new DOMMatrix(transformStyle);\n      scaleX = matrix.a;\n      scaleY = matrix.d;\n    }\n    var zoomStyle = getComputedStyle(tranformElement).zoom;\n    if (zoomStyle !== 'none') {\n      var bodyZoom = getZoomValue(document.body);\n      scaleX = bodyZoom * scaleX;\n      scaleY = bodyZoom * scaleY;\n    }\n  }\n  element.style.top = pos.position.top / scaleY + pos.offsetY - top / scaleY + 'px';\n  element.style.left = pos.position.left / scaleX + pos.offsetX - left / scaleX + 'px';\n}\nexport function getZoomValue(element) {\n  var zoomValue = getComputedStyle(element).zoom;\n  return parseFloat(zoomValue) || 1; // Default zoom value is 1 (no zoom)\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @returns {HTMLElement} The modified element.\n */\nexport function getTransformElement(element) {\n  while (element) {\n    var transform = window.getComputedStyle(element).transform;\n    var zoom = getZoomValue(document.body);\n    if (transform && transform !== 'none' || zoom && zoom !== 1) {\n      return element;\n    }\n    if (element === document.body) {\n      return null;\n    }\n    element = element.offsetParent || element.parentElement;\n  }\n  return null;\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {PositionLocation} pos - specifies theloaction\n * @param {boolean} fixedParent - specifies the boolean\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\nfunction updateElementData(target, edge, pos, fixedParent, elementRect) {\n  pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);\n  edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);\n  edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);\n  edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);\n  edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);\n}\n/**\n *\n * @param {EdgeOffset} eStatus - specifies the status\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client\n * @returns {void}\n */\nfunction setPosition(eStatus, pos, elementRect) {\n  eStatus.TL = {\n    top: pos.position.top + pos.offsetY,\n    left: pos.position.left + pos.offsetX\n  };\n  eStatus.TR = {\n    top: eStatus.TL.top,\n    left: eStatus.TL.left + elementRect.width\n  };\n  eStatus.BL = {\n    top: eStatus.TL.top + elementRect.height,\n    left: eStatus.TL.left\n  };\n  eStatus.BR = {\n    top: eStatus.TL.top + elementRect.height,\n    left: eStatus.TL.left + elementRect.width\n  };\n}\n/**\n *\n * @param {number} left - specifies the  number\n * @param {number} right - specifies the number\n * @returns {LeftCorners} - returns the value\n */\nfunction leftCollideCheck(left, right) {\n  //eslint-disable-next-line\n  var leftSide = false,\n    rightSide = false;\n  if (left - getBodyScrollLeft() < ContainerLeft()) {\n    leftSide = true;\n  }\n  if (right > ContainerRight()) {\n    rightSide = true;\n  }\n  return {\n    leftSide: leftSide,\n    rightSide: rightSide\n  };\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifes the element\n * @param {EdgeOffset} tEdge - specifies the edge offset\n * @param {PositionLocation} pos - specifes the location\n * @param {ClientRect} elementRect - specifies the client\n * @param {boolean} deepCheck - specifies the boolean value\n * @returns {void}\n */\nfunction leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n  var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);\n  if (tEdge.TL.left - getBodyScrollLeft() <= ContainerLeft()) {\n    collideSide.leftSide = false;\n  }\n  if (tEdge.TR.left > ContainerRight()) {\n    collideSide.rightSide = false;\n  }\n  if (collideSide.leftSide && !collideSide.rightSide || !collideSide.leftSide && collideSide.rightSide) {\n    if (pos.posX === 'right') {\n      pos.posX = 'left';\n    } else {\n      pos.posX = 'right';\n    }\n    pos.offsetX = pos.offsetX + elementRect.width;\n    pos.offsetX = -1 * pos.offsetX;\n    pos.position = calculatePosition(target, pos.posX, pos.posY, false);\n    setPosition(edge, pos, elementRect);\n    if (deepCheck) {\n      leftFlip(target, edge, tEdge, pos, elementRect, false);\n    }\n  }\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {EdgeOffset} tEdge - specifies the offset\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @param {boolean} deepCheck - specifies the boolean\n * @returns {void}\n */\nfunction topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n  var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);\n  if (tEdge.TL.top - getBodyScrollTop() <= ContainerTop()) {\n    collideSide.topSide = false;\n  }\n  if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {\n    collideSide.bottomSide = false;\n  }\n  if (collideSide.topSide && !collideSide.bottomSide || !collideSide.topSide && collideSide.bottomSide) {\n    if (pos.posY === 'top') {\n      pos.posY = 'bottom';\n    } else {\n      pos.posY = 'top';\n    }\n    pos.offsetY = pos.offsetY + elementRect.height;\n    pos.offsetY = -1 * pos.offsetY;\n    pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);\n    setPosition(edge, pos, elementRect);\n    if (deepCheck) {\n      topFlip(target, edge, tEdge, pos, elementRect, false);\n    }\n  }\n}\n/**\n *\n * @param {number} top - specifies the number\n * @param {number} bottom - specifies the number\n * @returns {TopCorners} - retyrns the value\n */\nfunction topCollideCheck(top, bottom) {\n  //eslint-disable-next-line\n  var topSide = false,\n    bottomSide = false;\n  if (top - getBodyScrollTop() < ContainerTop()) {\n    topSide = true;\n  }\n  if (bottom > ContainerBottom()) {\n    bottomSide = true;\n  }\n  return {\n    topSide: topSide,\n    bottomSide: bottomSide\n  };\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerWidth() {\n  return targetContainer.getBoundingClientRect().width;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerHeight() {\n  return targetContainer.getBoundingClientRect().height;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerLeft() {\n  return targetContainer.getBoundingClientRect().left;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerTop() {\n  return targetContainer.getBoundingClientRect().top;\n}\n//eslint-disable-next-line\nfunction ContainerTop() {\n  if (targetContainer) {\n    return getTargetContainerTop();\n  }\n  return 0;\n}\n//eslint-disable-next-line\nfunction ContainerLeft() {\n  if (targetContainer) {\n    return getTargetContainerLeft();\n  }\n  return 0;\n}\n//eslint-disable-next-line\nfunction ContainerRight() {\n  if (targetContainer) {\n    return getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth();\n  }\n  return getBodyScrollLeft() + getViewPortWidth();\n}\n//eslint-disable-next-line\nfunction ContainerBottom() {\n  if (targetContainer) {\n    return getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight();\n  }\n  return getBodyScrollTop() + getViewPortHeight();\n}\n/**\n * @returns {number} - returns the scroll top value\n */\nfunction getBodyScrollTop() {\n  // if(targetContainer)\n  //     return targetContainer.scrollTop;\n  return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;\n}\n/**\n * @returns {number} - returns the scroll left value\n */\nfunction getBodyScrollLeft() {\n  // if(targetContainer)\n  //     return targetContainer.scrollLeft;\n  return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;\n}\n/**\n * @returns {number} - returns the viewport height\n */\nfunction getViewPortHeight() {\n  return window.innerHeight;\n}\n/**\n * @returns {number} - returns the viewport width\n */\nfunction getViewPortWidth() {\n  var windowWidth = window.innerWidth;\n  var documentReact = document.documentElement.getBoundingClientRect();\n  var offsetWidth = isNullOrUndefined(document.documentElement) ? 0 : documentReact.width;\n  return windowWidth - (windowWidth - offsetWidth);\n}\n/**\n * @returns {void}\n */\nexport function destroy() {\n  targetContainer = null;\n  parentDocument = null;\n}","map":{"version":3,"names":["calculatePosition","isNullOrUndefined","parentDocument","targetContainer","fit","element","viewPortElement","axis","position","X","Y","left","top","elemData","getBoundingClientRect","ownerDocument","containerWidth","getTargetContainerWidth","getViewPortWidth","containerLeft","ContainerLeft","containerRight","ContainerRight","overLeft","overRight","width","containerHeight","getTargetContainerHeight","getViewPortHeight","containerTop","ContainerTop","containerBottom","ContainerBottom","overTop","overBottom","height","isCollide","x","y","elemOffset","data","elementRect","right","bottom","yAxis","topCollideCheck","xAxis","leftCollideCheck","topSide","push","rightSide","leftSide","bottomSide","flip","target","offsetX","offsetY","positionX","positionY","fixedParent","tEdge","TL","TR","BL","BR","eEdge","window","getComputedStyle","display","oldVisibility","style","visibility","removeProperty","pos","posX","posY","updateElementData","setPosition","leftFlip","topFlip","setPopup","offsetParent","scaleX","scaleY","tranformElement","getTransformElement","transformStyle","transform","matrix","DOMMatrix","a","d","zoomStyle","zoom","bodyZoom","getZoomValue","document","body","zoomValue","parseFloat","parentElement","edge","eStatus","getBodyScrollLeft","deepCheck","collideSide","getBodyScrollTop","innerHeight","getTargetContainerLeft","getTargetContainerTop","documentElement","scrollTop","scrollLeft","windowWidth","innerWidth","documentReact","offsetWidth","destroy"],"sources":["D:/weektable/frontend/node_modules/@syncfusion/ej2-popups/src/common/collision.js"],"sourcesContent":["/**\n * Collision module.\n */\nimport { calculatePosition } from './position';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nvar parentDocument;\nvar targetContainer;\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision coordinates\n * @param {OffsetPosition} position - specifies the position\n * @returns {void}\n */\nexport function fit(element, viewPortElement, axis, position) {\n    if (viewPortElement === void 0) { viewPortElement = null; }\n    if (axis === void 0) { axis = { X: false, Y: false }; }\n    if (!axis.Y && !axis.X) {\n        return { left: 0, top: 0 };\n    }\n    var elemData = element.getBoundingClientRect();\n    targetContainer = viewPortElement;\n    parentDocument = element.ownerDocument;\n    if (!position) {\n        position = calculatePosition(element, 'left', 'top');\n    }\n    if (axis.X) {\n        var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();\n        var containerLeft = ContainerLeft();\n        var containerRight = ContainerRight();\n        var overLeft = containerLeft - position.left;\n        var overRight = position.left + elemData.width - containerRight;\n        if (elemData.width > containerWidth) {\n            if (overLeft > 0 && overRight <= 0) {\n                position.left = containerRight - elemData.width;\n            }\n            else if (overRight > 0 && overLeft <= 0) {\n                position.left = containerLeft;\n            }\n            else {\n                position.left = overLeft > overRight ? (containerRight - elemData.width) : containerLeft;\n            }\n        }\n        else if (overLeft > 0) {\n            position.left += overLeft;\n        }\n        else if (overRight > 0) {\n            position.left -= overRight;\n        }\n    }\n    if (axis.Y) {\n        var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();\n        var containerTop = ContainerTop();\n        var containerBottom = ContainerBottom();\n        var overTop = containerTop - position.top;\n        var overBottom = position.top + elemData.height - containerBottom;\n        if (elemData.height > containerHeight) {\n            if (overTop > 0 && overBottom <= 0) {\n                position.top = containerBottom - elemData.height;\n            }\n            else if (overBottom > 0 && overTop <= 0) {\n                position.top = containerTop;\n            }\n            else {\n                position.top = overTop > overBottom ? (containerBottom - elemData.height) : containerTop;\n            }\n        }\n        else if (overTop > 0) {\n            position.top += overTop;\n        }\n        else if (overBottom > 0) {\n            position.top -= overBottom;\n        }\n    }\n    return position;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the html element\n * @param {HTMLElement} viewPortElement - specifies the html element\n * @param {number} x - specifies the number\n * @param {number} y - specifies the number\n * @returns {string[]} - returns the string value\n */\nexport function isCollide(element, viewPortElement, x, y) {\n    if (viewPortElement === void 0) { viewPortElement = null; }\n    var elemOffset = calculatePosition(element, 'left', 'top');\n    if (x) {\n        elemOffset.left = x;\n    }\n    if (y) {\n        elemOffset.top = y;\n    }\n    var data = [];\n    targetContainer = viewPortElement;\n    parentDocument = element.ownerDocument;\n    var elementRect = element.getBoundingClientRect();\n    var top = elemOffset.top;\n    var left = elemOffset.left;\n    var right = elemOffset.left + elementRect.width;\n    var bottom = elemOffset.top + elementRect.height;\n    var yAxis = topCollideCheck(top, bottom);\n    var xAxis = leftCollideCheck(left, right);\n    if (yAxis.topSide) {\n        data.push('top');\n    }\n    if (xAxis.rightSide) {\n        data.push('right');\n    }\n    if (xAxis.leftSide) {\n        data.push('left');\n    }\n    if (yAxis.bottomSide) {\n        data.push('bottom');\n    }\n    return data;\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {HTMLElement} target - specifies the element\n * @param {number} offsetX - specifies the number\n * @param {number} offsetY - specifies the number\n * @param {string} positionX - specifies the string value\n * @param {string} positionY - specifies the string value\n * @param {HTMLElement} viewPortElement - specifies the element\n * @param {CollisionCoordinates} axis - specifies the collision axis\n * @param {boolean} fixedParent - specifies the boolean\n * @returns {void}\n */\nexport function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, \n/* eslint-disable */\naxis, fixedParent) {\n    if (viewPortElement === void 0) { viewPortElement = null; }\n    if (axis === void 0) { axis = { X: true, Y: true }; }\n    if (!target || !element || !positionX || !positionY || (!axis.X && !axis.Y)) {\n        return;\n    }\n    var tEdge = { TL: null,\n        TR: null,\n        BL: null,\n        BR: null\n    }, eEdge = {\n        TL: null,\n        TR: null,\n        BL: null,\n        BR: null\n        /* eslint-enable */\n    };\n    var elementRect;\n    if (window.getComputedStyle(element).display === 'none') {\n        var oldVisibility = element.style.visibility;\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        elementRect = element.getBoundingClientRect();\n        element.style.removeProperty('display');\n        element.style.visibility = oldVisibility;\n    }\n    else {\n        elementRect = element.getBoundingClientRect();\n    }\n    var pos = {\n        posX: positionX, posY: positionY, offsetX: offsetX, offsetY: offsetY, position: { left: 0, top: 0 }\n    };\n    targetContainer = viewPortElement;\n    parentDocument = target.ownerDocument;\n    updateElementData(target, tEdge, pos, fixedParent, elementRect);\n    setPosition(eEdge, pos, elementRect);\n    if (axis.X) {\n        leftFlip(target, eEdge, tEdge, pos, elementRect, true);\n    }\n    if (axis.Y && tEdge.TL.top > -1) {\n        topFlip(target, eEdge, tEdge, pos, elementRect, true);\n    }\n    setPopup(element, pos, elementRect);\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\nfunction setPopup(element, pos, elementRect) {\n    var left = 0;\n    var top = 0;\n    if (element.offsetParent != null\n        && (getComputedStyle(element.offsetParent).position === 'absolute' ||\n            getComputedStyle(element.offsetParent).position === 'relative')) {\n        var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);\n        left = data.left;\n        top = data.top;\n    }\n    var scaleX = 1;\n    var scaleY = 1;\n    var tranformElement = getTransformElement(element);\n    if (tranformElement) {\n        var transformStyle = getComputedStyle(tranformElement).transform;\n        if (transformStyle !== 'none') {\n            var matrix = new DOMMatrix(transformStyle);\n            scaleX = matrix.a;\n            scaleY = matrix.d;\n        }\n        var zoomStyle = getComputedStyle(tranformElement).zoom;\n        if (zoomStyle !== 'none') {\n            var bodyZoom = getZoomValue(document.body);\n            scaleX = bodyZoom * scaleX;\n            scaleY = bodyZoom * scaleY;\n        }\n    }\n    element.style.top = ((pos.position.top / scaleY) + pos.offsetY - (top / scaleY)) + 'px';\n    element.style.left = ((pos.position.left / scaleX) + pos.offsetX - (left / scaleX)) + 'px';\n}\nexport function getZoomValue(element) {\n    var zoomValue = getComputedStyle(element).zoom;\n    return parseFloat(zoomValue) || 1; // Default zoom value is 1 (no zoom)\n}\n/**\n *\n * @param {HTMLElement} element - specifies the element\n * @returns {HTMLElement} The modified element.\n */\nexport function getTransformElement(element) {\n    while (element) {\n        var transform = window.getComputedStyle(element).transform;\n        var zoom = getZoomValue(document.body);\n        if ((transform && transform !== 'none') || (zoom && zoom !== 1)) {\n            return element;\n        }\n        if (element === document.body) {\n            return null;\n        }\n        element = (element.offsetParent || element.parentElement);\n    }\n    return null;\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {PositionLocation} pos - specifies theloaction\n * @param {boolean} fixedParent - specifies the boolean\n * @param {ClientRect} elementRect - specifies the client rect\n * @returns {void}\n */\nfunction updateElementData(target, edge, pos, fixedParent, elementRect) {\n    pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);\n    edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);\n    edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);\n    edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);\n    edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);\n}\n/**\n *\n * @param {EdgeOffset} eStatus - specifies the status\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client\n * @returns {void}\n */\nfunction setPosition(eStatus, pos, elementRect) {\n    eStatus.TL = { top: pos.position.top + pos.offsetY, left: pos.position.left + pos.offsetX };\n    eStatus.TR = { top: eStatus.TL.top, left: eStatus.TL.left + elementRect.width };\n    eStatus.BL = { top: eStatus.TL.top + elementRect.height,\n        left: eStatus.TL.left };\n    eStatus.BR = { top: eStatus.TL.top + elementRect.height,\n        left: eStatus.TL.left + elementRect.width };\n}\n/**\n *\n * @param {number} left - specifies the  number\n * @param {number} right - specifies the number\n * @returns {LeftCorners} - returns the value\n */\nfunction leftCollideCheck(left, right) {\n    //eslint-disable-next-line\n    var leftSide = false, rightSide = false;\n    if (((left - getBodyScrollLeft()) < ContainerLeft())) {\n        leftSide = true;\n    }\n    if (right > ContainerRight()) {\n        rightSide = true;\n    }\n    return { leftSide: leftSide, rightSide: rightSide };\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifes the element\n * @param {EdgeOffset} tEdge - specifies the edge offset\n * @param {PositionLocation} pos - specifes the location\n * @param {ClientRect} elementRect - specifies the client\n * @param {boolean} deepCheck - specifies the boolean value\n * @returns {void}\n */\nfunction leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n    var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);\n    if ((tEdge.TL.left - getBodyScrollLeft()) <= ContainerLeft()) {\n        collideSide.leftSide = false;\n    }\n    if (tEdge.TR.left > ContainerRight()) {\n        collideSide.rightSide = false;\n    }\n    if ((collideSide.leftSide && !collideSide.rightSide) || (!collideSide.leftSide && collideSide.rightSide)) {\n        if (pos.posX === 'right') {\n            pos.posX = 'left';\n        }\n        else {\n            pos.posX = 'right';\n        }\n        pos.offsetX = pos.offsetX + elementRect.width;\n        pos.offsetX = -1 * pos.offsetX;\n        pos.position = calculatePosition(target, pos.posX, pos.posY, false);\n        setPosition(edge, pos, elementRect);\n        if (deepCheck) {\n            leftFlip(target, edge, tEdge, pos, elementRect, false);\n        }\n    }\n}\n/**\n *\n * @param {HTMLElement} target - specifies the element\n * @param {EdgeOffset} edge - specifies the offset\n * @param {EdgeOffset} tEdge - specifies the offset\n * @param {PositionLocation} pos - specifies the location\n * @param {ClientRect} elementRect - specifies the client rect\n * @param {boolean} deepCheck - specifies the boolean\n * @returns {void}\n */\nfunction topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {\n    var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);\n    if ((tEdge.TL.top - getBodyScrollTop()) <= ContainerTop()) {\n        collideSide.topSide = false;\n    }\n    if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {\n        collideSide.bottomSide = false;\n    }\n    if ((collideSide.topSide && !collideSide.bottomSide) || (!collideSide.topSide && collideSide.bottomSide)) {\n        if (pos.posY === 'top') {\n            pos.posY = 'bottom';\n        }\n        else {\n            pos.posY = 'top';\n        }\n        pos.offsetY = pos.offsetY + elementRect.height;\n        pos.offsetY = -1 * pos.offsetY;\n        pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);\n        setPosition(edge, pos, elementRect);\n        if (deepCheck) {\n            topFlip(target, edge, tEdge, pos, elementRect, false);\n        }\n    }\n}\n/**\n *\n * @param {number} top - specifies the number\n * @param {number} bottom - specifies the number\n * @returns {TopCorners} - retyrns the value\n */\nfunction topCollideCheck(top, bottom) {\n    //eslint-disable-next-line\n    var topSide = false, bottomSide = false;\n    if ((top - getBodyScrollTop()) < ContainerTop()) {\n        topSide = true;\n    }\n    if (bottom > ContainerBottom()) {\n        bottomSide = true;\n    }\n    return { topSide: topSide, bottomSide: bottomSide };\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerWidth() {\n    return targetContainer.getBoundingClientRect().width;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerHeight() {\n    return targetContainer.getBoundingClientRect().height;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerLeft() {\n    return targetContainer.getBoundingClientRect().left;\n}\n/**\n * @returns {void}\n */\nfunction getTargetContainerTop() {\n    return targetContainer.getBoundingClientRect().top;\n}\n//eslint-disable-next-line\nfunction ContainerTop() {\n    if (targetContainer) {\n        return getTargetContainerTop();\n    }\n    return 0;\n}\n//eslint-disable-next-line\nfunction ContainerLeft() {\n    if (targetContainer) {\n        return getTargetContainerLeft();\n    }\n    return 0;\n}\n//eslint-disable-next-line\nfunction ContainerRight() {\n    if (targetContainer) {\n        return (getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth());\n    }\n    return (getBodyScrollLeft() + getViewPortWidth());\n}\n//eslint-disable-next-line\nfunction ContainerBottom() {\n    if (targetContainer) {\n        return (getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight());\n    }\n    return (getBodyScrollTop() + getViewPortHeight());\n}\n/**\n * @returns {number} - returns the scroll top value\n */\nfunction getBodyScrollTop() {\n    // if(targetContainer)\n    //     return targetContainer.scrollTop;\n    return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;\n}\n/**\n * @returns {number} - returns the scroll left value\n */\nfunction getBodyScrollLeft() {\n    // if(targetContainer)\n    //     return targetContainer.scrollLeft;\n    return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;\n}\n/**\n * @returns {number} - returns the viewport height\n */\nfunction getViewPortHeight() {\n    return window.innerHeight;\n}\n/**\n * @returns {number} - returns the viewport width\n */\nfunction getViewPortWidth() {\n    var windowWidth = window.innerWidth;\n    var documentReact = document.documentElement.getBoundingClientRect();\n    var offsetWidth = (isNullOrUndefined(document.documentElement)) ? 0 : documentReact.width;\n    return windowWidth - (windowWidth - offsetWidth);\n}\n/**\n * @returns {void}\n */\nexport function destroy() {\n    targetContainer = null;\n    parentDocument = null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}