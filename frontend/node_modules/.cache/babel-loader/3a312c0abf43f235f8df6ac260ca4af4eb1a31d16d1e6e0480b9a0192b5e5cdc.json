{"ast":null,"code":"/* eslint-disable */\nimport { DecompressorHuffmanTree } from './decompressor-huffman-tree';\nimport { Utils } from './utils';\nimport { ChecksumCalculator } from './checksum-calculator';\nvar CompressedStreamReader = /** @class */function () {\n  function CompressedStreamReader(stream, bNoWrap) {\n    /// <summary>\n    /// Code lengths for the code length alphabet.\n    /// </summary>\n    this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    /// <summary>\n    /// Mask for compression method to be decoded from 16-bit header.\n    /// </summary>\n    this.DEF_HEADER_METHOD_MASK = 15 << 8;\n    /// <summary>\n    /// Mask for compression info to be decoded from 16-bit header.\n    /// </summary>\n    this.DEF_HEADER_INFO_MASK = 240 << 8;\n    /// <summary>\n    /// Mask for check bits to be decoded from 16-bit header.\n    /// </summary>\n    this.DEF_HEADER_FLAGS_FCHECK = 31;\n    /// <summary>\n    /// Mask for dictionary presence to be decoded from 16-bit header.\n    /// </summary>\n    this.DEF_HEADER_FLAGS_FDICT = 32;\n    /// <summary>\n    /// Mask for compression level to be decoded from 16-bit header.\n    /// </summary>\n    this.DEF_HEADER_FLAGS_FLEVEL = 192;\n    /// <summary>\n    /// Maximum size of the data window.\n    /// </summary>\n    this.DEF_MAX_WINDOW_SIZE = 65535;\n    /// <summary>\n    /// Maximum length of the repeatable block.\n    /// </summary>\n    this.DEF_HUFFMAN_REPEATE_MAX = 258;\n    /// <summary>\n    /// End of the block sign.\n    /// </summary>\n    this.DEF_HUFFMAN_END_BLOCK = 256;\n    /// <summary>\n    /// Minimal length code.\n    /// </summary>\n    this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;\n    /// <summary>\n    /// Maximal length code.\n    /// </summary>\n    this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;\n    /// <summary>\n    /// Maximal distance code.\n    /// </summary>\n    this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;\n    /// <summary>\n    /// Currently calculated checksum,\n    /// based on Adler32 algorithm.\n    /// </summary>\n    this.mCheckSum = 1;\n    /// <summary>\n    /// Currently read 4 bytes.\n    /// </summary>\n    this.tBuffer = 0;\n    /// <summary>\n    /// Count of bits that are in buffer.\n    /// </summary>\n    this.mBufferedBits = 0;\n    /// <summary>\n    /// Temporary buffer.\n    /// </summary>\n    this.mTempBuffer = new Uint8Array(4);\n    /// <summary>\n    /// 32k buffer for unpacked data.\n    /// </summary>\n    this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);\n    /// <summary>\n    /// No wrap mode.\n    /// </summary>\n    this.mbNoWrap = false;\n    /// <summary>\n    /// Window size, can not be larger than 32k.\n    /// </summary>\n    this.mWindowSize = 0;\n    /// <summary>\n    /// Current position in output stream.\n    /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n    /// </summary>\n    this.mCurrentPosition = 0;\n    /// <summary>\n    /// Data length.\n    /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n    /// </summary>\n    this.mDataLength = 0;\n    /// <summary>\n    /// Specifies wheather next block can to be read.\n    /// Reading can be denied because the header of the last block have been read.\n    /// </summary>\n    this.mbCanReadNextBlock = true;\n    /// <summary>\n    /// Specifies wheather user can read more data from stream.\n    /// </summary>\n    this.mbCanReadMoreData = true;\n    /// <summary>\n    /// Specifies wheather checksum has been read.\n    /// </summary>\n    this.mbCheckSumRead = false;\n    if (stream == null) {\n      throw new DOMException('stream');\n    }\n    if (stream.length === 0) {\n      throw new DOMException('stream - string can not be empty');\n    }\n    DecompressorHuffmanTree.init();\n    this.mInputStream = new Stream(stream);\n    this.mbNoWrap = bNoWrap;\n    if (!this.mbNoWrap) {\n      this.readZLibHeader();\n    }\n    this.decodeBlockHeader();\n  }\n  Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n    get: function () {\n      return this.tBuffer;\n    },\n    set: function (value) {\n      this.tBuffer = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  /// <summary>\n  /// Reads specified count of bits without adjusting position.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be read.</param>\n  /// <returns>Read value.</returns>\n  CompressedStreamReader.prototype.peekBits = function (count) {\n    if (count < 0) {\n      throw new DOMException('count', 'Bits count can not be less than zero.');\n    }\n    if (count > 32) {\n      throw new DOMException('count', 'Count of bits is too large.');\n    }\n    // If buffered data is not enough to give result,\n    // fill buffer.\n    if (this.mBufferedBits < count) {\n      this.fillBuffer();\n    }\n    // If you want to read 4 bytes and there is partial data in\n    // buffer, than you will fail.\n    if (this.mBufferedBits < count) {\n      return -1;\n    }\n    // Create bitmask for reading of count bits\n    var bitMask = ~(4294967295 << count);\n    var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);\n    //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n    return result;\n  };\n  CompressedStreamReader.prototype.fillBuffer = function () {\n    var length = 4 - (this.mBufferedBits >> 3) - ((this.mBufferedBits & 7) !== 0 ? 1 : 0);\n    if (length === 0) {\n      return;\n    }\n    //TODO: fix this\n    var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n    for (var i = 0; i < bytesRead; i++) {\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer | Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits));\n      this.mBufferedBits += 8;\n    }\n    //TODO: fix this\n  };\n  /// <summary>\n  /// Skips specified count of bits.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be skipped.</param>\n  CompressedStreamReader.prototype.skipBits = function (count) {\n    if (count < 0) {\n      throw new DOMException('count', 'Bits count can not be less than zero.');\n    }\n    if (count === 0) {\n      return;\n    }\n    if (count >= this.mBufferedBits) {\n      count -= this.mBufferedBits;\n      this.mBufferedBits = 0;\n      this.mBuffer = 0;\n      // if something left, skip it.\n      if (count > 0) {\n        // Skip entire bytes.\n        this.mInputStream.position += count >> 3; //TODO: fix this\n        count &= 7;\n        // Skip bits.\n        if (count > 0) {\n          this.fillBuffer();\n          this.mBufferedBits -= count;\n          this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n      }\n    } else {\n      this.mBufferedBits -= count;\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n    }\n  };\n  Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n    get: function () {\n      return this.mBufferedBits;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /// <summary>\n  /// Reads ZLib header with compression method and flags.\n  /// </summary>\n  CompressedStreamReader.prototype.readZLibHeader = function () {\n    // first 8 bits - compression Method and flags\n    // 8 other - flags\n    var header = this.readInt16();\n    //Debug.WriteLine( BitsToString( header ) );\n    if (header === -1) {\n      throw new DOMException('Header of the stream can not be read.');\n    }\n    if (header % 31 !== 0) {\n      throw new DOMException('Header checksum illegal');\n    }\n    if ((header & this.DEF_HEADER_METHOD_MASK) !== 8 << 8) {\n      throw new DOMException('Unsupported compression method.');\n    }\n    this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n    if (this.mWindowSize > 65535) {\n      throw new DOMException('Unsupported window size for deflate compression method.');\n    }\n    if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n      // Get dictionary.\n      throw new DOMException('Custom dictionary is not supported at the moment.');\n    }\n  };\n  /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n  CompressedStreamReader.prototype.readInt16 = function () {\n    var result = this.readBits(8) << 8;\n    result |= this.readBits(8);\n    return result;\n  };\n  /// <summary>\n  /// Reads specified count of bits from stream.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be read.</param>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n  CompressedStreamReader.prototype.readBits = function (count) {\n    var result = this.peekBits(count);\n    if (result === -1) {\n      return -1;\n    }\n    this.mBufferedBits -= count;\n    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n    return result;\n  };\n  /// <summary>\n  /// Reads and decodes block of data.\n  /// </summary>\n  /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n  CompressedStreamReader.prototype.decodeBlockHeader = function () {\n    if (!this.mbCanReadNextBlock) {\n      return false;\n    }\n    var bFinalBlock = this.readBits(1);\n    if (bFinalBlock === -1) {\n      return false;\n    }\n    var blockType = this.readBits(2);\n    if (blockType === -1) {\n      return false;\n    }\n    this.mbCanReadNextBlock = bFinalBlock === 0;\n    //      ChecksumReset();\n    switch (blockType) {\n      case 0:\n        // Uncompressed data\n        this.mbReadingUncompressed = true;\n        this.skipToBoundary();\n        var length_1 = this.readInt16Inverted();\n        var lengthComplement = this.readInt16Inverted();\n        if (length_1 !== (lengthComplement ^ 0xffff)) {\n          throw new DOMException('Wrong block length.');\n        }\n        if (length_1 > 65535) {\n          throw new DOMException('Uncompressed block length can not be more than 65535.');\n        }\n        this.mUncompressedDataLength = length_1;\n        this.mCurrentLengthTree = null;\n        this.mCurrentDistanceTree = null;\n        break;\n      case 1:\n        // Compressed data with fixed huffman codes.\n        this.mbReadingUncompressed = false;\n        this.mUncompressedDataLength = -1;\n        this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n        this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n        break;\n      case 2:\n        // Compressed data with dynamic huffman codes.\n        this.mbReadingUncompressed = false;\n        this.mUncompressedDataLength = -1;\n        var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n        this.mCurrentLengthTree = trees.lengthTree;\n        this.mCurrentDistanceTree = trees.distanceTree;\n        break;\n      default:\n        throw new DOMException('Wrong block type.');\n    }\n    return true;\n  };\n  /// <summary>\n  /// Discards left-most partially used byte.\n  /// </summary>\n  CompressedStreamReader.prototype.skipToBoundary = function () {\n    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n    this.mBufferedBits &= ~7;\n  };\n  /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n  CompressedStreamReader.prototype.readInt16Inverted = function () {\n    var result = this.readBits(8);\n    result |= this.readBits(8) << 8;\n    return result;\n  };\n  /// <summary>\n  /// Reades dynamic huffman codes from block header.\n  /// </summary>\n  /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n  /// <param name=\"distanceTree\">Distances tree.</param>\n  CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n    var bLastSymbol = 0;\n    var iLengthsCount = this.readBits(5);\n    var iDistancesCount = this.readBits(5);\n    var iCodeLengthsCount = this.readBits(4);\n    if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n      throw new DOMException('Wrong dynamic huffman codes.');\n    }\n    iLengthsCount += 257;\n    iDistancesCount += 1;\n    var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n    var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n    var arrDecoderCodeLengths = new Uint8Array(19);\n    iCodeLengthsCount += 4;\n    var iCurrentCode = 0;\n    while (iCurrentCode < iCodeLengthsCount) {\n      var len = this.readBits(3);\n      if (len < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n      arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n    }\n    var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n    iCurrentCode = 0;\n    for (;;) {\n      var symbol = void 0;\n      var bNeedBreak = false;\n      symbol = treeInternalDecoder.unpackSymbol(this);\n      while ((symbol & ~15) === 0) {\n        arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n        if (iCurrentCode === iResultingCodeLengthsCount) {\n          bNeedBreak = true;\n          break;\n        }\n        symbol = treeInternalDecoder.unpackSymbol(this);\n      }\n      if (bNeedBreak) {\n        break;\n      }\n      if (symbol < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n      if (symbol >= 17) {\n        bLastSymbol = 0;\n      } else if (iCurrentCode === 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n      var miRepSymbol = symbol - 16;\n      var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n      var count = this.readBits(bits);\n      if (count < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n      count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n      if (iCurrentCode + count > iResultingCodeLengthsCount) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n      while (count-- > 0) {\n        arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n      }\n      if (iCurrentCode === iResultingCodeLengthsCount) {\n        break;\n      }\n    }\n    var tempArray = new Uint8Array(iLengthsCount);\n    tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);\n    //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n    //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n    lengthTree = new DecompressorHuffmanTree(tempArray);\n    tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);\n    //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n    distanceTree = new DecompressorHuffmanTree(tempArray);\n    return {\n      'lengthTree': lengthTree,\n      'distanceTree': distanceTree\n    };\n  };\n  /// <summary>\n  /// Decodes huffman codes.\n  /// </summary>\n  /// <returns>True if some data was read.</returns>\n  CompressedStreamReader.prototype.readHuffman = function () {\n    var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n    var dataRead = false;\n    //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n    var readdata = {};\n    // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n    // if we should not, we will have buffer overrun.\n    while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n      var symbol = void 0;\n      symbol = this.mCurrentLengthTree.unpackSymbol(this);\n      // Only codes 0..255 are valid independent symbols.\n      while ((symbol & ~0xff) === 0) {\n        readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n        this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n        dataRead = true;\n        if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n          return true;\n        }\n        //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n        symbol = this.mCurrentLengthTree.unpackSymbol(this);\n      }\n      if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n        if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n          throw new DOMException('Illegal code.');\n        }\n        var numDataRead = dataRead ? 1 : 0;\n        this.mbCanReadMoreData = this.decodeBlockHeader();\n        var numReadMore = this.mbCanReadMoreData ? 1 : 0;\n        return numDataRead | numReadMore ? true : false;\n      }\n      if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n        throw new DOMException('Illegal repeat code length.');\n      }\n      var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n      var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n      if (iRepeatExtraBits > 0) {\n        var extra = this.readBits(iRepeatExtraBits);\n        if (extra < 0) {\n          throw new DOMException('Wrong data.');\n        }\n        iRepeatLength += extra;\n      }\n      // Unpack repeat distance.\n      symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n      if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n        throw new DOMException('Wrong distance code.');\n      }\n      var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n      iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n      if (iRepeatExtraBits > 0) {\n        var extra = this.readBits(iRepeatExtraBits);\n        if (extra < 0) {\n          throw new DOMException('Wrong data.');\n        }\n        iRepeatDistance += extra;\n      }\n      // Copy data in slow repeat mode\n      for (var i = 0; i < iRepeatLength; i++) {\n        this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] = this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n        this.mDataLength++;\n        free--;\n      }\n      dataRead = true;\n    }\n    return dataRead;\n  };\n  /// <summary>\n  /// Reads data to buffer.\n  /// </summary>\n  /// <param name=\"buffer\">Output buffer for data.</param>\n  /// <param name=\"offset\">Offset in output data.</param>\n  /// <param name=\"length\">Length of the data to be read.</param>\n  /// <returns>Count of bytes actually read.</returns>\n  CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n    if (buffer == null) {\n      throw new DOMException('buffer');\n    }\n    if (offset < 0 || offset > buffer.length - 1) {\n      throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n    }\n    if (length < 0 || length > buffer.length - offset) {\n      throw new DOMException('length', 'Length is illegal.');\n    }\n    var initialLength = length;\n    while (length > 0) {\n      // Read from internal buffer.\n      if (this.mCurrentPosition < this.mDataLength) {\n        // Position in buffer array.\n        var inBlockPosition = this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE;\n        // We can not read more than we have in buffer at once,\n        // and we not read more than till the array end.\n        var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, this.mDataLength - this.mCurrentPosition);\n        // Reading not more, than the rest of the buffer.\n        dataToCopy = Math.min(dataToCopy, length);\n        //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        // Copy data.\n        //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n        //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n        Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);\n        // Correct position, length,\n        this.mCurrentPosition += dataToCopy;\n        offset += dataToCopy;\n        length -= dataToCopy;\n      } else {\n        if (!this.mbCanReadMoreData) {\n          break;\n        }\n        var oldDataLength = this.mDataLength;\n        if (!this.mbReadingUncompressed) {\n          if (!this.readHuffman()) {\n            break;\n          }\n        } else {\n          if (this.mUncompressedDataLength === 0) {\n            // If there is no more data in stream, just exit.\n            this.mbCanReadMoreData = this.decodeBlockHeader();\n            if (!this.mbCanReadMoreData) {\n              break;\n            }\n          } else {\n            // Position of the data end in block buffer.\n            var inBlockPosition = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;\n            var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n            var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n            if (dataToRead !== dataRead) {\n              throw new DOMException('Not enough data in stream.');\n            }\n            this.mUncompressedDataLength -= dataRead;\n            this.mDataLength += dataRead;\n          }\n        }\n        if (oldDataLength < this.mDataLength) {\n          var start = oldDataLength % this.DEF_MAX_WINDOW_SIZE;\n          var end = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;\n          if (start < end) {\n            this.checksumUpdate(this.mBlockBuffer, start, end - start);\n          } else {\n            this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n            if (end > 0) {\n              this.checksumUpdate(this.mBlockBuffer, 0, end);\n            }\n          }\n        }\n      }\n    }\n    if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n      this.skipToBoundary();\n      var checkSum = this.readInt32();\n      //Debug.Assert( checkSum == mCheckSum, \"\" );\n      if (checkSum !== this.mCheckSum) {\n        throw new DOMException('Checksum check failed.');\n      }\n      this.mbCheckSumRead = true;\n    }\n    return initialLength - length;\n  };\n  /// <summary>\n  /// Reads array of bytes.\n  /// </summary>\n  /// <param name=\"buffer\">Output buffer.</param>\n  /// <param name=\"offset\">Offset in output buffer.</param>\n  /// <param name=\"length\">Length of the data to be read.</param>\n  /// <returns>Count of bytes actually read to the buffer.</returns>\n  CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n    if (buffer == null) {\n      throw new DOMException('buffer');\n    }\n    if (offset < 0 || offset > buffer.length - 1) {\n      throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n    }\n    if (length < 0) {\n      throw new DOMException('length\", \"Length can not be less than zero.');\n    }\n    if (length > buffer.length - offset) {\n      throw new DOMException('length\", \"Length is too large.');\n    }\n    if ((this.mBufferedBits & 7) !== 0) {\n      throw new DOMException('Reading of unalligned data is not supported.');\n    }\n    if (length === 0) {\n      return 0;\n    }\n    var result = 0;\n    while (this.mBufferedBits > 0 && length > 0) {\n      buffer[offset++] = this.mBuffer;\n      this.mBufferedBits -= 8;\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n      length--;\n      result++;\n    }\n    if (length > 0) {\n      //TODO: Fix this.\n      result += this.mInputStream.read(buffer, offset, length);\n    }\n    return result;\n  };\n  /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n  CompressedStreamReader.prototype.readInt32 = function () {\n    var result = this.readBits(8) << 24;\n    result |= this.readBits(8) << 16;\n    result |= this.readBits(8) << 8;\n    result |= this.readBits(8);\n    return result;\n  };\n  /// <summary>\n  /// Updates checksum by calculating checksum of the\n  /// given buffer and adding it to current value.\n  /// </summary>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n  CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n    ChecksumCalculator.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n  };\n  CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);\n  /// <summary>\n  /// Minimum count of repetions.\n  /// </summary>\n  CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];\n  /// <summary>\n  /// Bits, that responds for different repetion modes.\n  /// </summary>\n  CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];\n  /// <summary>\n  /// Length bases.\n  /// </summary>\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];\n  /// <summary>\n  /// Length extended bits count.\n  /// </summary>\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n  /// <summary>\n  /// Distance bases.\n  /// </summary>\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];\n  /// <summary>\n  /// Distance extanded bits count.\n  /// </summary>\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n  return CompressedStreamReader;\n}();\nexport { CompressedStreamReader };\nvar Stream = /** @class */function () {\n  function Stream(input) {\n    this.position = 0;\n    this.inputStream = new Uint8Array(input.buffer);\n  }\n  Object.defineProperty(Stream.prototype, \"length\", {\n    get: function () {\n      return this.inputStream.buffer.byteLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Stream.prototype.read = function (buffer, start, length) {\n    var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n    var data = temp.subarray(0, length);\n    buffer.set(data, 0);\n    this.position += data.byteLength;\n    return data.byteLength;\n  };\n  Stream.prototype.readByte = function () {\n    return this.inputStream[this.position++];\n  };\n  Stream.prototype.write = function (inputBuffer, offset, count) {\n    Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);\n    // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n    // this.inputStream.set(inputBuffer, offset);\n    this.position += count;\n  };\n  Stream.prototype.toByteArray = function () {\n    return new Uint8Array(this.inputStream.buffer);\n  };\n  return Stream;\n}();\nexport { Stream };\n/* eslint-enable */","map":{"version":3,"names":["DecompressorHuffmanTree","Utils","ChecksumCalculator","CompressedStreamReader","stream","bNoWrap","defaultHuffmanDynamicTree","DEF_HEADER_METHOD_MASK","DEF_HEADER_INFO_MASK","DEF_HEADER_FLAGS_FCHECK","DEF_HEADER_FLAGS_FDICT","DEF_HEADER_FLAGS_FLEVEL","DEF_MAX_WINDOW_SIZE","DEF_HUFFMAN_REPEATE_MAX","DEF_HUFFMAN_END_BLOCK","DEF_HUFFMAN_LENGTH_MINIMUMCODE","DEF_HUFFMAN_LENGTH_MAXIMUMCODE","DEF_HUFFMAN_DISTANCE_MAXIMUMCODE","mCheckSum","tBuffer","mBufferedBits","mTempBuffer","Uint8Array","mBlockBuffer","mbNoWrap","mWindowSize","mCurrentPosition","mDataLength","mbCanReadNextBlock","mbCanReadMoreData","mbCheckSumRead","DOMException","length","init","mInputStream","Stream","readZLibHeader","decodeBlockHeader","Object","defineProperty","prototype","get","set","value","enumerable","configurable","peekBits","count","fillBuffer","bitMask","result","bitConverterUintToInt32","mBuffer","bytesRead","read","i","bitConverterInt32ToUint","skipBits","position","header","readInt16","Math","pow","readBits","bFinalBlock","blockType","mbReadingUncompressed","skipToBoundary","length_1","readInt16Inverted","lengthComplement","mUncompressedDataLength","mCurrentLengthTree","mCurrentDistanceTree","lengthTree","distanceTree","trees","decodeDynamicHeader","bLastSymbol","iLengthsCount","iDistancesCount","iCodeLengthsCount","iResultingCodeLengthsCount","arrResultingCodeLengths","arrDecoderCodeLengths","iCurrentCode","len","treeInternalDecoder","symbol","bNeedBreak","unpackSymbol","miRepSymbol","bits","DEF_HUFFMAN_DYNTREE_REPEAT_BITS","DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS","tempArray","subarray","slice","readHuffman","free","dataRead","readdata","numDataRead","numReadMore","iRepeatLength","DEF_HUFFMAN_REPEAT_LENGTH_BASE","iRepeatExtraBits","DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION","extra","DEF_HUFFMAN_REPEAT_DISTANCE_BASE","iRepeatDistance","DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION","buffer","offset","initialLength","inBlockPosition","dataToCopy","min","arrayCopy","oldDataLength","dataToRead","readPackedBytes","start","end","checksumUpdate","checkSum","readInt32","ChecksumUpdate","DEF_REVERSE_BITS","input","inputStream","byteLength","temp","data","readByte","write","inputBuffer","toByteArray"],"sources":["D:/weektable/frontend/node_modules/@syncfusion/ej2-compression/src/compression-reader.js"],"sourcesContent":["/* eslint-disable */\nimport { DecompressorHuffmanTree } from './decompressor-huffman-tree';\nimport { Utils } from './utils';\nimport { ChecksumCalculator } from './checksum-calculator';\nvar CompressedStreamReader = /** @class */ (function () {\n    function CompressedStreamReader(stream, bNoWrap) {\n        /// <summary>\n        /// Code lengths for the code length alphabet.\n        /// </summary>\n        this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n        /// <summary>\n        /// Mask for compression method to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_METHOD_MASK = 15 << 8;\n        /// <summary>\n        /// Mask for compression info to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_INFO_MASK = 240 << 8;\n        /// <summary>\n        /// Mask for check bits to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FCHECK = 31;\n        /// <summary>\n        /// Mask for dictionary presence to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FDICT = 32;\n        /// <summary>\n        /// Mask for compression level to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FLEVEL = 192;\n        /// <summary>\n        /// Maximum size of the data window.\n        /// </summary>\n        this.DEF_MAX_WINDOW_SIZE = 65535;\n        /// <summary>\n        /// Maximum length of the repeatable block.\n        /// </summary>\n        this.DEF_HUFFMAN_REPEATE_MAX = 258;\n        /// <summary>\n        /// End of the block sign.\n        /// </summary>\n        this.DEF_HUFFMAN_END_BLOCK = 256;\n        /// <summary>\n        /// Minimal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;\n        /// <summary>\n        /// Maximal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;\n        /// <summary>\n        /// Maximal distance code.\n        /// </summary>\n        this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;\n        /// <summary>\n        /// Currently calculated checksum,\n        /// based on Adler32 algorithm.\n        /// </summary>\n        this.mCheckSum = 1;\n        /// <summary>\n        /// Currently read 4 bytes.\n        /// </summary>\n        this.tBuffer = 0;\n        /// <summary>\n        /// Count of bits that are in buffer.\n        /// </summary>\n        this.mBufferedBits = 0;\n        /// <summary>\n        /// Temporary buffer.\n        /// </summary>\n        this.mTempBuffer = new Uint8Array(4);\n        /// <summary>\n        /// 32k buffer for unpacked data.\n        /// </summary>\n        this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);\n        /// <summary>\n        /// No wrap mode.\n        /// </summary>\n        this.mbNoWrap = false;\n        /// <summary>\n        /// Window size, can not be larger than 32k.\n        /// </summary>\n        this.mWindowSize = 0;\n        /// <summary>\n        /// Current position in output stream.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mCurrentPosition = 0;\n        /// <summary>\n        /// Data length.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mDataLength = 0;\n        /// <summary>\n        /// Specifies wheather next block can to be read.\n        /// Reading can be denied because the header of the last block have been read.\n        /// </summary>\n        this.mbCanReadNextBlock = true;\n        /// <summary>\n        /// Specifies wheather user can read more data from stream.\n        /// </summary>\n        this.mbCanReadMoreData = true;\n        /// <summary>\n        /// Specifies wheather checksum has been read.\n        /// </summary>\n        this.mbCheckSumRead = false;\n        if (stream == null) {\n            throw new DOMException('stream');\n        }\n        if (stream.length === 0) {\n            throw new DOMException('stream - string can not be empty');\n        }\n        DecompressorHuffmanTree.init();\n        this.mInputStream = new Stream(stream);\n        this.mbNoWrap = bNoWrap;\n        if (!this.mbNoWrap) {\n            this.readZLibHeader();\n        }\n        this.decodeBlockHeader();\n    }\n    Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n        get: function () {\n            return this.tBuffer;\n        },\n        set: function (value) {\n            this.tBuffer = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    /// <summary>\n    /// Reads specified count of bits without adjusting position.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>Read value.</returns>\n    CompressedStreamReader.prototype.peekBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count > 32) {\n            throw new DOMException('count', 'Count of bits is too large.');\n        }\n        // If buffered data is not enough to give result,\n        // fill buffer.\n        if (this.mBufferedBits < count) {\n            this.fillBuffer();\n        }\n        // If you want to read 4 bytes and there is partial data in\n        // buffer, than you will fail.\n        if (this.mBufferedBits < count) {\n            return -1;\n        }\n        // Create bitmask for reading of count bits\n        var bitMask = ~(4294967295 << count);\n        var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);\n        //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n        return result;\n    };\n    CompressedStreamReader.prototype.fillBuffer = function () {\n        var length = 4 - (this.mBufferedBits >> 3) -\n            (((this.mBufferedBits & 7) !== 0) ? 1 : 0);\n        if (length === 0) {\n            return;\n        }\n        //TODO: fix this\n        var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n        for (var i = 0; i < bytesRead; i++) {\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer |\n                (Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits)));\n            this.mBufferedBits += 8;\n        }\n        //TODO: fix this\n    };\n    /// <summary>\n    /// Skips specified count of bits.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be skipped.</param>\n    CompressedStreamReader.prototype.skipBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count === 0) {\n            return;\n        }\n        if (count >= this.mBufferedBits) {\n            count -= this.mBufferedBits;\n            this.mBufferedBits = 0;\n            this.mBuffer = 0;\n            // if something left, skip it.\n            if (count > 0) {\n                // Skip entire bytes.\n                this.mInputStream.position += (count >> 3); //TODO: fix this\n                count &= 7;\n                // Skip bits.\n                if (count > 0) {\n                    this.fillBuffer();\n                    this.mBufferedBits -= count;\n                    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n                }\n            }\n        }\n        else {\n            this.mBufferedBits -= count;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n    };\n    Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n        get: function () {\n            return this.mBufferedBits;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Reads ZLib header with compression method and flags.\n    /// </summary>\n    CompressedStreamReader.prototype.readZLibHeader = function () {\n        // first 8 bits - compression Method and flags\n        // 8 other - flags\n        var header = this.readInt16();\n        //Debug.WriteLine( BitsToString( header ) );\n        if (header === -1) {\n            throw new DOMException('Header of the stream can not be read.');\n        }\n        if (header % 31 !== 0) {\n            throw new DOMException('Header checksum illegal');\n        }\n        if ((header & this.DEF_HEADER_METHOD_MASK) !== (8 << 8)) {\n            throw new DOMException('Unsupported compression method.');\n        }\n        this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n        if (this.mWindowSize > 65535) {\n            throw new DOMException('Unsupported window size for deflate compression method.');\n        }\n        if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n            // Get dictionary.\n            throw new DOMException('Custom dictionary is not supported at the moment.');\n        }\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16 = function () {\n        var result = (this.readBits(8) << 8);\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Reads specified count of bits from stream.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readBits = function (count) {\n        var result = this.peekBits(count);\n        if (result === -1) {\n            return -1;\n        }\n        this.mBufferedBits -= count;\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        return result;\n    };\n    /// <summary>\n    /// Reads and decodes block of data.\n    /// </summary>\n    /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n    CompressedStreamReader.prototype.decodeBlockHeader = function () {\n        if (!this.mbCanReadNextBlock) {\n            return false;\n        }\n        var bFinalBlock = this.readBits(1);\n        if (bFinalBlock === -1) {\n            return false;\n        }\n        var blockType = this.readBits(2);\n        if (blockType === -1) {\n            return false;\n        }\n        this.mbCanReadNextBlock = (bFinalBlock === 0);\n        //      ChecksumReset();\n        switch (blockType) {\n            case 0:\n                // Uncompressed data\n                this.mbReadingUncompressed = true;\n                this.skipToBoundary();\n                var length_1 = this.readInt16Inverted();\n                var lengthComplement = this.readInt16Inverted();\n                if (length_1 !== (lengthComplement ^ 0xffff)) {\n                    throw new DOMException('Wrong block length.');\n                }\n                if (length_1 > 65535) {\n                    throw new DOMException('Uncompressed block length can not be more than 65535.');\n                }\n                this.mUncompressedDataLength = length_1;\n                this.mCurrentLengthTree = null;\n                this.mCurrentDistanceTree = null;\n                break;\n            case 1:\n                // Compressed data with fixed huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n                this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n                break;\n            case 2:\n                // Compressed data with dynamic huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n                this.mCurrentLengthTree = trees.lengthTree;\n                this.mCurrentDistanceTree = trees.distanceTree;\n                break;\n            default:\n                throw new DOMException('Wrong block type.');\n        }\n        return true;\n    };\n    /// <summary>\n    /// Discards left-most partially used byte.\n    /// </summary>\n    CompressedStreamReader.prototype.skipToBoundary = function () {\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n        this.mBufferedBits &= ~7;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16Inverted = function () {\n        var result = (this.readBits(8));\n        result |= this.readBits(8) << 8;\n        return result;\n    };\n    /// <summary>\n    /// Reades dynamic huffman codes from block header.\n    /// </summary>\n    /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n    /// <param name=\"distanceTree\">Distances tree.</param>\n    CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n        var bLastSymbol = 0;\n        var iLengthsCount = this.readBits(5);\n        var iDistancesCount = this.readBits(5);\n        var iCodeLengthsCount = this.readBits(4);\n        if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n            throw new DOMException('Wrong dynamic huffman codes.');\n        }\n        iLengthsCount += 257;\n        iDistancesCount += 1;\n        var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n        var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n        var arrDecoderCodeLengths = new Uint8Array(19);\n        iCodeLengthsCount += 4;\n        var iCurrentCode = 0;\n        while (iCurrentCode < iCodeLengthsCount) {\n            var len = this.readBits(3);\n            if (len < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n        }\n        var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n        iCurrentCode = 0;\n        for (;;) {\n            var symbol = void 0;\n            var bNeedBreak = false;\n            symbol = treeInternalDecoder.unpackSymbol(this);\n            while ((symbol & ~15) === 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n                if (iCurrentCode === iResultingCodeLengthsCount) {\n                    bNeedBreak = true;\n                    break;\n                }\n                symbol = treeInternalDecoder.unpackSymbol(this);\n            }\n            if (bNeedBreak) {\n                break;\n            }\n            if (symbol < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            if (symbol >= 17) {\n                bLastSymbol = 0;\n            }\n            else if (iCurrentCode === 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            var miRepSymbol = symbol - 16;\n            var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n            var count = this.readBits(bits);\n            if (count < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n            if (iCurrentCode + count > iResultingCodeLengthsCount) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            while (count-- > 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n            }\n            if (iCurrentCode === iResultingCodeLengthsCount) {\n                break;\n            }\n        }\n        var tempArray = new Uint8Array(iLengthsCount);\n        tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);\n        //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n        lengthTree = new DecompressorHuffmanTree(tempArray);\n        tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);\n        //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n        distanceTree = new DecompressorHuffmanTree(tempArray);\n        return { 'lengthTree': lengthTree, 'distanceTree': distanceTree };\n    };\n    /// <summary>\n    /// Decodes huffman codes.\n    /// </summary>\n    /// <returns>True if some data was read.</returns>\n    CompressedStreamReader.prototype.readHuffman = function () {\n        var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n        var dataRead = false;\n        //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n        var readdata = {};\n        // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n        // if we should not, we will have buffer overrun.\n        while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n            var symbol = void 0;\n            symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            // Only codes 0..255 are valid independent symbols.\n            while (((symbol) & ~0xff) === 0) {\n                readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                dataRead = true;\n                if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n                    return true;\n                }\n                //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n                symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            }\n            if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n                if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n                    throw new DOMException('Illegal code.');\n                }\n                var numDataRead = dataRead ? 1 : 0;\n                this.mbCanReadMoreData = this.decodeBlockHeader();\n                var numReadMore = (this.mbCanReadMoreData) ? 1 : 0;\n                return (numDataRead | numReadMore) ? true : false;\n            }\n            if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n                throw new DOMException('Illegal repeat code length.');\n            }\n            var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatLength += extra;\n            }\n            // Unpack repeat distance.\n            symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n            if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n                throw new DOMException('Wrong distance code.');\n            }\n            var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n            iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatDistance += extra;\n            }\n            // Copy data in slow repeat mode\n            for (var i = 0; i < iRepeatLength; i++) {\n                this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] =\n                    this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n                this.mDataLength++;\n                free--;\n            }\n            dataRead = true;\n        }\n        return dataRead;\n    };\n    /// <summary>\n    /// Reads data to buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer for data.</param>\n    /// <param name=\"offset\">Offset in output data.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read.</returns>\n    CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n        }\n        if (length < 0 || length > buffer.length - offset) {\n            throw new DOMException('length', 'Length is illegal.');\n        }\n        var initialLength = length;\n        while (length > 0) {\n            // Read from internal buffer.\n            if (this.mCurrentPosition < this.mDataLength) {\n                // Position in buffer array.\n                var inBlockPosition = (this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE);\n                // We can not read more than we have in buffer at once,\n                // and we not read more than till the array end.\n                var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, (this.mDataLength - this.mCurrentPosition));\n                // Reading not more, than the rest of the buffer.\n                dataToCopy = Math.min(dataToCopy, length);\n                //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n                // Copy data.\n                //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n                //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n                Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);\n                // Correct position, length,\n                this.mCurrentPosition += dataToCopy;\n                offset += dataToCopy;\n                length -= dataToCopy;\n            }\n            else {\n                if (!this.mbCanReadMoreData) {\n                    break;\n                }\n                var oldDataLength = this.mDataLength;\n                if (!this.mbReadingUncompressed) {\n                    if (!this.readHuffman()) {\n                        break;\n                    }\n                }\n                else {\n                    if (this.mUncompressedDataLength === 0) {\n                        // If there is no more data in stream, just exit.\n                        this.mbCanReadMoreData = this.decodeBlockHeader();\n                        if (!(this.mbCanReadMoreData)) {\n                            break;\n                        }\n                    }\n                    else {\n                        // Position of the data end in block buffer.\n                        var inBlockPosition = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                        var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n                        var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n                        if (dataToRead !== dataRead) {\n                            throw new DOMException('Not enough data in stream.');\n                        }\n                        this.mUncompressedDataLength -= dataRead;\n                        this.mDataLength += dataRead;\n                    }\n                }\n                if (oldDataLength < this.mDataLength) {\n                    var start = (oldDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    var end = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    if (start < end) {\n                        this.checksumUpdate(this.mBlockBuffer, start, end - start);\n                    }\n                    else {\n                        this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n                        if (end > 0) {\n                            this.checksumUpdate(this.mBlockBuffer, 0, end);\n                        }\n                    }\n                }\n            }\n        }\n        if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n            this.skipToBoundary();\n            var checkSum = this.readInt32();\n            //Debug.Assert( checkSum == mCheckSum, \"\" );\n            if (checkSum !== this.mCheckSum) {\n                throw new DOMException('Checksum check failed.');\n            }\n            this.mbCheckSumRead = true;\n        }\n        return initialLength - length;\n    };\n    /// <summary>\n    /// Reads array of bytes.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer.</param>\n    /// <param name=\"offset\">Offset in output buffer.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read to the buffer.</returns>\n    CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n        }\n        if (length < 0) {\n            throw new DOMException('length\", \"Length can not be less than zero.');\n        }\n        if (length > buffer.length - offset) {\n            throw new DOMException('length\", \"Length is too large.');\n        }\n        if ((this.mBufferedBits & 7) !== 0) {\n            throw new DOMException('Reading of unalligned data is not supported.');\n        }\n        if (length === 0) {\n            return 0;\n        }\n        var result = 0;\n        while (this.mBufferedBits > 0 && length > 0) {\n            buffer[offset++] = (this.mBuffer);\n            this.mBufferedBits -= 8;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n            length--;\n            result++;\n        }\n        if (length > 0) {\n            //TODO: Fix this.\n            result += this.mInputStream.read(buffer, offset, length);\n        }\n        return result;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt32 = function () {\n        var result = this.readBits(8) << 24;\n        result |= this.readBits(8) << 16;\n        result |= this.readBits(8) << 8;\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n        ChecksumCalculator.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n    };\n    CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);\n    /// <summary>\n    /// Minimum count of repetions.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];\n    /// <summary>\n    /// Bits, that responds for different repetion modes.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];\n    /// <summary>\n    /// Length bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n    ];\n    /// <summary>\n    /// Length extended bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0\n    ];\n    /// <summary>\n    /// Distance bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n    ];\n    /// <summary>\n    /// Distance extanded bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13\n    ];\n    return CompressedStreamReader;\n}());\nexport { CompressedStreamReader };\nvar Stream = /** @class */ (function () {\n    function Stream(input) {\n        this.position = 0;\n        this.inputStream = new Uint8Array(input.buffer);\n    }\n    Object.defineProperty(Stream.prototype, \"length\", {\n        get: function () {\n            return this.inputStream.buffer.byteLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Stream.prototype.read = function (buffer, start, length) {\n        var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n        var data = temp.subarray(0, length);\n        buffer.set(data, 0);\n        this.position += data.byteLength;\n        return data.byteLength;\n    };\n    Stream.prototype.readByte = function () {\n        return this.inputStream[this.position++];\n    };\n    Stream.prototype.write = function (inputBuffer, offset, count) {\n        Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);\n        // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n        // this.inputStream.set(inputBuffer, offset);\n        this.position += count;\n    };\n    Stream.prototype.toByteArray = function () {\n        return new Uint8Array(this.inputStream.buffer);\n    };\n    return Stream;\n}());\nexport { Stream };\n/* eslint-enable */ \n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}